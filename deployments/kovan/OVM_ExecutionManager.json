{
  "address": "0x13E0344eB59423F9f34B3f4394aE922b48E86275",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "minTransactionGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxTransactionGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxGasPerQueuePerEpoch",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "secondsPerEpoch",
              "type": "uint256"
            }
          ],
          "internalType": "struct iOVM_ExecutionManager.GasMeterConfig",
          "name": "_gasMeterConfig",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "ovmCHAINID",
              "type": "uint256"
            }
          ],
          "internalType": "struct iOVM_ExecutionManager.GlobalContext",
          "name": "_globalContext",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "getMaxTransactionGasLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_maxTransactionGasLimit",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmADDRESS",
      "outputs": [
        {
          "internalType": "address",
          "name": "_ADDRESS",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "ovmCALL",
      "outputs": [
        {
          "internalType": "bool",
          "name": "_success",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "_returndata",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmCALLER",
      "outputs": [
        {
          "internalType": "address",
          "name": "_CALLER",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmCHAINID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_CHAINID",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_bytecode",
          "type": "bytes"
        }
      ],
      "name": "ovmCREATE",
      "outputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_bytecode",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_salt",
          "type": "bytes32"
        }
      ],
      "name": "ovmCREATE2",
      "outputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_messageHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "_v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "_r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_s",
          "type": "bytes32"
        }
      ],
      "name": "ovmCREATEEOA",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "ovmDELEGATECALL",
      "outputs": [
        {
          "internalType": "bool",
          "name": "_success",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "_returndata",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_length",
          "type": "uint256"
        }
      ],
      "name": "ovmEXTCODECOPY",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "_code",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "name": "ovmEXTCODEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "_EXTCODEHASH",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "name": "ovmEXTCODESIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_EXTCODESIZE",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmGASLIMIT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_GASLIMIT",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmGETNONCE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_nonce",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmL1QUEUEORIGIN",
      "outputs": [
        {
          "internalType": "enum Lib_OVMCodec.QueueOrigin",
          "name": "_queueOrigin",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmL1TXORIGIN",
      "outputs": [
        {
          "internalType": "address",
          "name": "_l1TxOrigin",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmNUMBER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_NUMBER",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "ovmREVERT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_nonce",
          "type": "uint256"
        }
      ],
      "name": "ovmSETNONCE",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        }
      ],
      "name": "ovmSLOAD",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "_value",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_value",
          "type": "bytes32"
        }
      ],
      "name": "ovmSSTORE",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "ovmSTATICCALL",
      "outputs": [
        {
          "internalType": "bool",
          "name": "_success",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "_returndata",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ovmTIMESTAMP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_TIMESTAMP",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "enum Lib_OVMCodec.QueueOrigin",
              "name": "l1QueueOrigin",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "l1TxOrigin",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "entrypoint",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "gasLimit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.Transaction",
          "name": "_transaction",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_ovmStateManager",
          "type": "address"
        }
      ],
      "name": "run",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_bytecode",
          "type": "bytes"
        }
      ],
      "name": "safeCREATE",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "enum Lib_OVMCodec.QueueOrigin",
              "name": "l1QueueOrigin",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "l1TxOrigin",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "entrypoint",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "gasLimit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.Transaction",
          "name": "_transaction",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "contract iOVM_StateManager",
          "name": "_ovmStateManager",
          "type": "address"
        }
      ],
      "name": "simulateMessage",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x36af51a4aa6e814bb6a7351d24ae3170f49ab7645f84a06a88a49368369f233b",
  "receipt": {
    "to": null,
    "from": "0x3a953298098CADCb621a40c1efCfb7DD73B727aF",
    "contractAddress": "0x13E0344eB59423F9f34B3f4394aE922b48E86275",
    "transactionIndex": 1,
    "gasUsed": "3207657",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0bf0d393ae9d4c3934b091dfb23f9336fb00e9a6adfc6a50256c1627ba9c267b",
    "transactionHash": "0x36af51a4aa6e814bb6a7351d24ae3170f49ab7645f84a06a88a49368369f233b",
    "logs": [],
    "blockNumber": 23635977,
    "cumulativeGasUsed": "3250822",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xe32CEbDb70aC8572Ebee537507784089Fb96a8Ad",
    {
      "minTransactionGasLimit": 20000,
      "maxTransactionGasLimit": 9000000,
      "maxGasPerQueuePerEpoch": 9000000,
      "secondsPerEpoch": 0
    },
    {
      "ovmCHAINID": 10
    }
  ],
  "solcInputHash": "167e1592944606d9f946a16ee2ddffd3",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTransactionGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTransactionGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPerQueuePerEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsPerEpoch\",\"type\":\"uint256\"}],\"internalType\":\"struct iOVM_ExecutionManager.GasMeterConfig\",\"name\":\"_gasMeterConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ovmCHAINID\",\"type\":\"uint256\"}],\"internalType\":\"struct iOVM_ExecutionManager.GlobalContext\",\"name\":\"_globalContext\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getMaxTransactionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTransactionGasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_ADDRESS\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"ovmCALL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_returndata\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmCALLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_CALLER\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmCHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_CHAINID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_bytecode\",\"type\":\"bytes\"}],\"name\":\"ovmCREATE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"ovmCREATE2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"ovmCREATEEOA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"ovmDELEGATECALL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_returndata\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"ovmEXTCODECOPY\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_code\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"ovmEXTCODEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_EXTCODEHASH\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"ovmEXTCODESIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_EXTCODESIZE\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmGASLIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_GASLIMIT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmGETNONCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmL1QUEUEORIGIN\",\"outputs\":[{\"internalType\":\"enum Lib_OVMCodec.QueueOrigin\",\"name\":\"_queueOrigin\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmL1TXORIGIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_l1TxOrigin\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmNUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_NUMBER\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"ovmREVERT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"ovmSETNONCE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"ovmSLOAD\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ovmSSTORE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"ovmSTATICCALL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_returndata\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmTIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_TIMESTAMP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"enum Lib_OVMCodec.QueueOrigin\",\"name\":\"l1QueueOrigin\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"l1TxOrigin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"entrypoint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_ovmStateManager\",\"type\":\"address\"}],\"name\":\"run\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_bytecode\",\"type\":\"bytes\"}],\"name\":\"safeCREATE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"enum Lib_OVMCodec.QueueOrigin\",\"name\":\"l1QueueOrigin\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"l1TxOrigin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"entrypoint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"contract iOVM_StateManager\",\"name\":\"_ovmStateManager\",\"type\":\"address\"}],\"name\":\"simulateMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed environment allowing us to execute OVM transactions deterministically on either Layer 1 or Layer 2. The EM's run() function is the first function called during the execution of any transaction on L2. For each context-dependent EVM operation the EM has a function which implements a corresponding OVM operation, which will read state from the State Manager contract. The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any context-dependent operations. Compiler used: solc Runtime target: EVM\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_libAddressManager\":\"Address of the Address Manager.\"}},\"ovmADDRESS()\":{\"returns\":{\"_ADDRESS\":\"Active ADDRESS within the current message context.\"}},\"ovmCALL(uint256,address,bytes)\":{\"params\":{\"_address\":\"Address of the contract to call.\",\"_calldata\":\"Data to send along with the call.\",\"_gasLimit\":\"Amount of gas to be passed into this call.\"},\"returns\":{\"_returndata\":\"Data returned by the call.\",\"_success\":\"Whether or not the call returned (rather than reverted).\"}},\"ovmCALLER()\":{\"returns\":{\"_CALLER\":\"Address of the CALLER within the current message context.\"}},\"ovmCHAINID()\":{\"returns\":{\"_CHAINID\":\"Value of the chain's CHAINID within the global context.\"}},\"ovmCREATE(bytes)\":{\"params\":{\"_bytecode\":\"Code to be used to CREATE a new contract.\"},\"returns\":{\"_contract\":\"Address of the created contract.\"}},\"ovmCREATE2(bytes,bytes32)\":{\"params\":{\"_bytecode\":\"Code to be used to CREATE2 a new contract.\",\"_salt\":\"Value used to determine the contract's address.\"},\"returns\":{\"_contract\":\"Address of the created contract.\"}},\"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\":{\"details\":\"Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks      because the contract we're creating is trusted (no need to do safety checking or to      handle unexpected reverts). Doesn't need to return an address because the address is      assumed to be the user's actual address.\",\"params\":{\"_messageHash\":\"Hash of a message signed by some user, for verification.\",\"_r\":\"Signature `r` parameter.\",\"_s\":\"Signature `s` parameter.\",\"_v\":\"Signature `v` parameter.\"}},\"ovmDELEGATECALL(uint256,address,bytes)\":{\"params\":{\"_address\":\"Address of the contract to call.\",\"_calldata\":\"Data to send along with the call.\",\"_gasLimit\":\"Amount of gas to be passed into this call.\"},\"returns\":{\"_returndata\":\"Data returned by the call.\",\"_success\":\"Whether or not the call returned (rather than reverted).\"}},\"ovmEXTCODECOPY(address,uint256,uint256)\":{\"params\":{\"_contract\":\"Address of the contract to copy code from.\",\"_length\":\"Total number of bytes to copy from the contract's code.\",\"_offset\":\"Offset in bytes from the start of contract code to copy beyond.\"},\"returns\":{\"_code\":\"Bytes of code copied from the requested contract.\"}},\"ovmEXTCODEHASH(address)\":{\"params\":{\"_contract\":\"Address of the contract to query the hash of.\"},\"returns\":{\"_EXTCODEHASH\":\"Hash of the requested contract.\"}},\"ovmEXTCODESIZE(address)\":{\"params\":{\"_contract\":\"Address of the contract to query the size of.\"},\"returns\":{\"_EXTCODESIZE\":\"Size of the requested contract in bytes.\"}},\"ovmGASLIMIT()\":{\"returns\":{\"_GASLIMIT\":\"Value of the block's GASLIMIT within the transaction context.\"}},\"ovmGETNONCE()\":{\"returns\":{\"_nonce\":\"Nonce of the current contract.\"}},\"ovmL1QUEUEORIGIN()\":{\"returns\":{\"_queueOrigin\":\"Address of the ovmL1QUEUEORIGIN within the current message context.\"}},\"ovmL1TXORIGIN()\":{\"returns\":{\"_l1TxOrigin\":\"Address of the account which sent the tx into L2 from L1.\"}},\"ovmNUMBER()\":{\"returns\":{\"_NUMBER\":\"Value of the NUMBER within the transaction context.\"}},\"ovmREVERT(bytes)\":{\"params\":{\"_data\":\"Bytes data to pass along with the REVERT.\"}},\"ovmSETNONCE(uint256)\":{\"params\":{\"_nonce\":\"New nonce for the current contract.\"}},\"ovmSLOAD(bytes32)\":{\"params\":{\"_key\":\"32 byte key of the storage slot to load.\"},\"returns\":{\"_value\":\"32 byte value of the requested storage slot.\"}},\"ovmSSTORE(bytes32,bytes32)\":{\"params\":{\"_key\":\"32 byte key of the storage slot to set.\",\"_value\":\"32 byte value for the storage slot.\"}},\"ovmSTATICCALL(uint256,address,bytes)\":{\"params\":{\"_address\":\"Address of the contract to call.\",\"_calldata\":\"Data to send along with the call.\",\"_gasLimit\":\"Amount of gas to be passed into this call.\"},\"returns\":{\"_returndata\":\"Data returned by the call.\",\"_success\":\"Whether or not the call returned (rather than reverted).\"}},\"ovmTIMESTAMP()\":{\"returns\":{\"_TIMESTAMP\":\"Value of the TIMESTAMP within the transaction context.\"}},\"run((uint256,uint256,uint8,address,address,uint256,bytes),address)\":{\"params\":{\"_ovmStateManager\":\"iOVM_StateManager implementation providing account state.\",\"_transaction\":\"Transaction data to be executed.\"}},\"safeCREATE(address,bytes)\":{\"details\":\"This function is implemented as `public` because we need to be able to revert a      contract creation without losing information about exactly *why* the contract reverted.      In particular, we want to be sure that contracts cannot trigger an INVALID_STATE_ACCESS      flag and then revert to reset the flag. We're able to do this by making an external      call from `ovmCREATE` and `ovmCREATE2` to `safeCREATE`, which can capture and relay      information before reverting.\",\"params\":{\"_address\":\"Address of the contract to associate with the one being created.\",\"_bytecode\":\"Code to be used to create the new contract.\"}},\"simulateMessage((uint256,uint256,uint8,address,address,uint256,bytes),address,address)\":{\"params\":{\"_from\":\"the OVM account the simulated call should be from.\",\"_transaction\":\"the message transaction to simulate.\"}}},\"title\":\"OVM_ExecutionManager\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"ovmADDRESS()\":{\"notice\":\"Overrides ADDRESS.\"},\"ovmCALL(uint256,address,bytes)\":{\"notice\":\"Overrides CALL.\"},\"ovmCALLER()\":{\"notice\":\"Overrides CALLER.\"},\"ovmCHAINID()\":{\"notice\":\"Overrides CHAINID.\"},\"ovmCREATE(bytes)\":{\"notice\":\"Overrides CREATE.\"},\"ovmCREATE2(bytes,bytes32)\":{\"notice\":\"Overrides CREATE2.\"},\"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\":{\"notice\":\"Creates a new EOA contract account, for account abstraction.\"},\"ovmDELEGATECALL(uint256,address,bytes)\":{\"notice\":\"Overrides DELEGATECALL.\"},\"ovmEXTCODECOPY(address,uint256,uint256)\":{\"notice\":\"Overrides EXTCODECOPY.\"},\"ovmEXTCODEHASH(address)\":{\"notice\":\"Overrides EXTCODEHASH.\"},\"ovmEXTCODESIZE(address)\":{\"notice\":\"Overrides EXTCODESIZE.\"},\"ovmGASLIMIT()\":{\"notice\":\"Overrides GASLIMIT.\"},\"ovmGETNONCE()\":{\"notice\":\"Retrieves the nonce of the current ovmADDRESS.\"},\"ovmL1QUEUEORIGIN()\":{\"notice\":\"Specifies from which L1 rollup queue this transaction originated from.\"},\"ovmL1TXORIGIN()\":{\"notice\":\"Specifies which L1 account, if any, sent this transaction by calling enqueue().\"},\"ovmNUMBER()\":{\"notice\":\"Overrides NUMBER.\"},\"ovmREVERT(bytes)\":{\"notice\":\"Overrides REVERT.\"},\"ovmSETNONCE(uint256)\":{\"notice\":\"Sets the nonce of the current ovmADDRESS.\"},\"ovmSLOAD(bytes32)\":{\"notice\":\"Overrides SLOAD.\"},\"ovmSSTORE(bytes32,bytes32)\":{\"notice\":\"Overrides SSTORE.\"},\"ovmSTATICCALL(uint256,address,bytes)\":{\"notice\":\"Overrides STATICCALL.\"},\"ovmTIMESTAMP()\":{\"notice\":\"Overrides TIMESTAMP.\"},\"run((uint256,uint256,uint8,address,address,uint256,bytes),address)\":{\"notice\":\"Starts the execution of a transaction via the OVM_ExecutionManager.\"},\"safeCREATE(address,bytes)\":{\"notice\":\"Performs the logic to create a contract and revert under various potential conditions.\"},\"simulateMessage((uint256,uint256,uint8,address,address,uint256,bytes),address,address)\":{\"notice\":\"Unreachable helper function for simulating eth_calls with an OVM message context. This function will throw an exception in all cases other than when used as a custom entrypoint in L2 Geth to simulate eth_call.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol\":\"OVM_ExecutionManager\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Interface Imports */\\nimport { iOVM_ECDSAContractAccount } from \\\"../../iOVM/accounts/iOVM_ECDSAContractAccount.sol\\\";\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_ECDSAUtils } from \\\"../../libraries/utils/Lib_ECDSAUtils.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\nimport { Lib_SafeMathWrapper } from \\\"../../libraries/wrappers/Lib_SafeMathWrapper.sol\\\";\\n\\n/**\\n * @title OVM_ECDSAContractAccount\\n * @dev The ECDSA Contract Account can be used as the implementation for a ProxyEOA deployed by the\\n * ovmCREATEEOA operation. It enables backwards compatibility with Ethereum's Layer 1, by \\n * providing eth_sign and EIP155 formatted transaction encodings.\\n *\\n * Compiler used: solc\\n * Runtime target: OVM\\n */\\ncontract OVM_ECDSAContractAccount is iOVM_ECDSAContractAccount {\\n\\n    address constant ETH_ERC20_ADDRESS = 0x4200000000000000000000000000000000000006;\\n    uint256 constant EXECUTION_VALIDATION_GAS_OVERHEAD = 25000; // TODO: should be the amount sufficient to cover the gas costs of all of the transactions up to and including the CALL/CREATE which forms the entrypoint of the transaction.\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Executes a signed transaction.\\n     * @param _transaction Signed EOA transaction.\\n     * @param _signatureType Hashing scheme used for the transaction (e.g., ETH signed message).\\n     * @param _v Signature `v` parameter.\\n     * @param _r Signature `r` parameter.\\n     * @param _s Signature `s` parameter.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function execute(\\n        bytes memory _transaction,\\n        Lib_OVMCodec.EOASignatureType _signatureType,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        override\\n        public\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bool isEthSign = _signatureType == Lib_OVMCodec.EOASignatureType.ETH_SIGNED_MESSAGE;\\n\\n        // Address of this contract within the ovm (ovmADDRESS) should be the same as the\\n        // recovered address of the user who signed this message. This is how we manage to shim\\n        // account abstraction even though the user isn't a contract.\\n        // Need to make sure that the transaction nonce is right and bump it if so.\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            Lib_ECDSAUtils.recover(\\n                _transaction,\\n                isEthSign,\\n                _v,\\n                _r,\\n                _s\\n            ) == Lib_SafeExecutionManagerWrapper.safeADDRESS(),\\n            \\\"Signature provided for EOA transaction execution is invalid.\\\"\\n        );\\n\\n        Lib_OVMCodec.EIP155Transaction memory decodedTx = Lib_OVMCodec.decodeEIP155Transaction(_transaction, isEthSign);\\n\\n        // Need to make sure that the transaction chainId is correct.\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            decodedTx.chainId == Lib_SafeExecutionManagerWrapper.safeCHAINID(),\\n            \\\"Transaction chainId does not match expected OVM chainId.\\\"\\n        );\\n\\n        // Need to make sure that the transaction nonce is right.\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            decodedTx.nonce == Lib_SafeExecutionManagerWrapper.safeGETNONCE(),\\n            \\\"Transaction nonce does not match the expected nonce.\\\"\\n        );\\n\\n        // TEMPORARY: Disable gas checks for minnet.\\n        // // Need to make sure that the gas is sufficient to execute the transaction.\\n        // Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n        //    gasleft() >= Lib_SafeMathWrapper.add(decodedTx.gasLimit, EXECUTION_VALIDATION_GAS_OVERHEAD),\\n        //    \\\"Gas is not sufficient to execute the transaction.\\\"\\n        // );\\n\\n        // Transfer fee to relayer.\\n        address relayer = Lib_SafeExecutionManagerWrapper.safeCALLER();\\n        uint256 fee = Lib_SafeMathWrapper.mul(decodedTx.gasLimit, decodedTx.gasPrice);\\n        (bool success, ) = Lib_SafeExecutionManagerWrapper.safeCALL(\\n            gasleft(),\\n            ETH_ERC20_ADDRESS,\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", relayer, fee)\\n        );\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            success == true,\\n            \\\"Fee was not transferred to relayer.\\\"\\n        );\\n\\n        // Contract creations are signalled by sending a transaction to the zero address.\\n        if (decodedTx.to == address(0)) {\\n            address created = Lib_SafeExecutionManagerWrapper.safeCREATE(\\n                decodedTx.gasLimit,\\n                decodedTx.data\\n            );\\n\\n            // EVM doesn't tell us whether a contract creation failed, even if it reverted during\\n            // initialization. Always return `true` for our success value here.\\n            return (true, abi.encode(created));\\n        } else {\\n            // We only want to bump the nonce for `ovmCALL` because `ovmCREATE` automatically bumps\\n            // the nonce of the calling account. Normally an EOA would bump the nonce for both\\n            // cases, but since this is a contract we'd end up bumping the nonce twice.\\n            Lib_SafeExecutionManagerWrapper.safeSETNONCE(decodedTx.nonce + 1);\\n\\n            return Lib_SafeExecutionManagerWrapper.safeCALL(\\n                decodedTx.gasLimit,\\n                decodedTx.to,\\n                decodedTx.data\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9eaaad64d70fb465dd323504f34ba44861dfe738621fce48e8a1e697405e592e\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../../libraries/utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_ECDSAUtils } from \\\"../../libraries/utils/Lib_ECDSAUtils.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title OVM_ProxyEOA\\n * @dev The Proxy EOA contract uses a delegate call to execute the logic in an implementation contract.\\n * In combination with the logic implemented in the ECDSA Contract Account, this enables a form of upgradable \\n * 'account abstraction' on layer 2. \\n * \\n * Compiler used: solc\\n * Runtime target: OVM\\n */\\ncontract OVM_ProxyEOA {\\n\\n    bytes32 constant IMPLEMENTATION_KEY = 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        address _implementation\\n    )\\n        public\\n    {\\n        _setImplementation(_implementation);\\n    }\\n\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback()\\n        external\\n    {\\n        (bool success, bytes memory returndata) = Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\\n            gasleft(),\\n            getImplementation(),\\n            msg.data\\n        );\\n\\n        if (success) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            Lib_SafeExecutionManagerWrapper.safeREVERT(\\n                string(returndata)\\n            );\\n        }\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function upgrade(\\n        address _implementation\\n    )\\n        external\\n    {\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            Lib_SafeExecutionManagerWrapper.safeADDRESS() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\\n            \\\"EOAs can only upgrade their own EOA implementation\\\"\\n        );\\n\\n        _setImplementation(_implementation);\\n    }\\n\\n    function getImplementation()\\n        public\\n        returns (\\n            address _implementation\\n        )\\n    {\\n        return address(uint160(uint256(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\\n                IMPLEMENTATION_KEY\\n            )\\n        )));\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function _setImplementation(\\n        address _implementation\\n    )\\n        internal\\n    {\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            IMPLEMENTATION_KEY,\\n            bytes32(uint256(uint160(_implementation)))\\n        );\\n    }\\n}\",\"keccak256\":\"0xfbc7e9737d04824f9c1b63fc2151a591c768e3b643d9b3c44405559c3ef19e5e\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_EthUtils } from \\\"../../libraries/utils/Lib_EthUtils.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_ExecutionManager } from \\\"../../iOVM/execution/iOVM_ExecutionManager.sol\\\";\\nimport { iOVM_StateManager } from \\\"../../iOVM/execution/iOVM_StateManager.sol\\\";\\nimport { iOVM_SafetyChecker } from \\\"../../iOVM/execution/iOVM_SafetyChecker.sol\\\";\\n\\n/* Contract Imports */\\nimport { OVM_ECDSAContractAccount } from \\\"../accounts/OVM_ECDSAContractAccount.sol\\\";\\nimport { OVM_ProxyEOA } from \\\"../accounts/OVM_ProxyEOA.sol\\\";\\nimport { OVM_DeployerWhitelist } from \\\"../precompiles/OVM_DeployerWhitelist.sol\\\";\\n\\n/**\\n * @title OVM_ExecutionManager\\n * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed\\n * environment allowing us to execute OVM transactions deterministically on either Layer 1 or\\n * Layer 2.\\n * The EM's run() function is the first function called during the execution of any\\n * transaction on L2.\\n * For each context-dependent EVM operation the EM has a function which implements a corresponding\\n * OVM operation, which will read state from the State Manager contract.\\n * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any\\n * context-dependent operations.\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract OVM_ExecutionManager is iOVM_ExecutionManager, Lib_AddressResolver {\\n\\n    /********************************\\n     * External Contract References *\\n     ********************************/\\n\\n    iOVM_SafetyChecker internal ovmSafetyChecker;\\n    iOVM_StateManager internal ovmStateManager;\\n\\n\\n    /*******************************\\n     * Execution Context Variables *\\n     *******************************/\\n\\n    GasMeterConfig internal gasMeterConfig;\\n    GlobalContext internal globalContext;\\n    TransactionContext internal transactionContext;\\n    MessageContext internal messageContext;\\n    TransactionRecord internal transactionRecord;\\n    MessageRecord internal messageRecord;\\n\\n\\n    /**************************\\n     * Gas Metering Constants *\\n     **************************/\\n\\n    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;\\n    uint256 constant NUISANCE_GAS_SLOAD = 20000;\\n    uint256 constant NUISANCE_GAS_SSTORE = 20000;\\n    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;\\n    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;\\n    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        GasMeterConfig memory _gasMeterConfig,\\n        GlobalContext memory _globalContext\\n    )\\n        public\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        ovmSafetyChecker = iOVM_SafetyChecker(resolve(\\\"OVM_SafetyChecker\\\"));\\n        gasMeterConfig = _gasMeterConfig;\\n        globalContext = _globalContext;\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Applies dynamically-sized refund to a transaction to account for the difference in execution\\n     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.\\n     * @param _cost Desired gas cost for the function after the refund.\\n     */\\n    modifier netGasCost(\\n        uint256 _cost\\n    ) {\\n        uint256 gasProvided = gasleft();\\n        _;\\n        uint256 gasUsed = gasProvided - gasleft();\\n\\n        // We want to refund everything *except* the specified cost.\\n        if (_cost < gasUsed) {\\n            transactionRecord.ovmGasRefund += gasUsed - _cost;\\n        }\\n    }\\n\\n    /**\\n     * Applies a fixed-size gas refund to a transaction to account for the difference in execution\\n     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.\\n     * @param _discount Amount of gas cost to refund for the ovmOPCODE.\\n     */\\n    modifier fixedGasDiscount(\\n        uint256 _discount\\n    ) {\\n        uint256 gasProvided = gasleft();\\n        _;\\n        uint256 gasUsed = gasProvided - gasleft();\\n\\n        // We want to refund the specified _discount, unless this risks underflow.\\n        if (_discount < gasUsed) {\\n            transactionRecord.ovmGasRefund += _discount;\\n        } else {\\n            // refund all we can without risking underflow.\\n            transactionRecord.ovmGasRefund += gasUsed;\\n        }\\n    }\\n\\n    /**\\n     * Makes sure we're not inside a static context.\\n     */\\n    modifier notStatic() {\\n        if (messageContext.isStatic == true) {\\n            _revertWithFlag(RevertFlag.STATIC_VIOLATION);\\n        }\\n        _;\\n    }\\n\\n\\n    /************************************\\n     * Transaction Execution Entrypoint *\\n     ************************************/\\n\\n    /**\\n     * Starts the execution of a transaction via the OVM_ExecutionManager.\\n     * @param _transaction Transaction data to be executed.\\n     * @param _ovmStateManager iOVM_StateManager implementation providing account state.\\n     */\\n    function run(\\n        Lib_OVMCodec.Transaction memory _transaction,\\n        address _ovmStateManager\\n    )\\n        override\\n        public\\n    {\\n        require(transactionContext.ovmNUMBER == 0, \\\"Only be callable at the start of a transaction\\\");\\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\\n        // address around in calldata).\\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\\n\\n        // Make sure this function can't be called by anyone except the owner of the\\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\\n        // this would make the `run` itself invalid.\\n        require(\\n            // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\\n            ovmStateManager.isAuthenticated(msg.sender),\\n            \\\"Only authenticated addresses in ovmStateManager can call this function\\\"\\n        );\\n\\n        // Initialize the execution context, must be initialized before we perform any gas metering\\n        // or we'll throw a nuisance gas error.\\n        _initContext(_transaction);\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        // // Check whether we need to start a new epoch, do so if necessary.\\n        // _checkNeedsNewEpoch(_transaction.timestamp);\\n\\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\\n        // reverts for INVALID_STATE_ACCESS.\\n        if (_isValidGasLimit(_transaction.gasLimit, _transaction.l1QueueOrigin) == false) {\\n            return;\\n        }\\n\\n        // Check gas right before the call to get total gas consumed by OVM transaction.\\n        uint256 gasProvided = gasleft();\\n\\n        // Run the transaction, make sure to meter the gas usage.\\n        ovmCALL(\\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\\n            _transaction.entrypoint,\\n            _transaction.data\\n        );\\n        uint256 gasUsed = gasProvided - gasleft();\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        // // Update the cumulative gas based on the amount of gas used.\\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\\n\\n        // Wipe the execution context.\\n        _resetContext();\\n\\n        // Reset the ovmStateManager.\\n        ovmStateManager = iOVM_StateManager(address(0));\\n    }\\n\\n\\n    /******************************\\n     * Opcodes: Execution Context *\\n     ******************************/\\n\\n    /**\\n     * @notice Overrides CALLER.\\n     * @return _CALLER Address of the CALLER within the current message context.\\n     */\\n    function ovmCALLER()\\n        override\\n        public\\n        view\\n        returns (\\n            address _CALLER\\n        )\\n    {\\n        return messageContext.ovmCALLER;\\n    }\\n\\n    /**\\n     * @notice Overrides ADDRESS.\\n     * @return _ADDRESS Active ADDRESS within the current message context.\\n     */\\n    function ovmADDRESS()\\n        override\\n        public\\n        view\\n        returns (\\n            address _ADDRESS\\n        )\\n    {\\n        return messageContext.ovmADDRESS;\\n    }\\n\\n    /**\\n     * @notice Overrides TIMESTAMP.\\n     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.\\n     */\\n    function ovmTIMESTAMP()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _TIMESTAMP\\n        )\\n    {\\n        return transactionContext.ovmTIMESTAMP;\\n    }\\n\\n    /**\\n     * @notice Overrides NUMBER.\\n     * @return _NUMBER Value of the NUMBER within the transaction context.\\n     */\\n    function ovmNUMBER()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _NUMBER\\n        )\\n    {\\n        return transactionContext.ovmNUMBER;\\n    }\\n\\n    /**\\n     * @notice Overrides GASLIMIT.\\n     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.\\n     */\\n    function ovmGASLIMIT()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _GASLIMIT\\n        )\\n    {\\n        return transactionContext.ovmGASLIMIT;\\n    }\\n\\n    /**\\n     * @notice Overrides CHAINID.\\n     * @return _CHAINID Value of the chain's CHAINID within the global context.\\n     */\\n    function ovmCHAINID()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _CHAINID\\n        )\\n    {\\n        return globalContext.ovmCHAINID;\\n    }\\n\\n    /*********************************\\n     * Opcodes: L2 Execution Context *\\n     *********************************/\\n\\n    /**\\n     * @notice Specifies from which L1 rollup queue this transaction originated from.\\n     * @return _queueOrigin Address of the ovmL1QUEUEORIGIN within the current message context.\\n     */\\n    function ovmL1QUEUEORIGIN()\\n        override\\n        public\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueOrigin _queueOrigin\\n        )\\n    {\\n        return transactionContext.ovmL1QUEUEORIGIN;\\n    }\\n\\n    /**\\n     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().\\n     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.\\n     */\\n    function ovmL1TXORIGIN()\\n        override\\n        public\\n        view\\n        returns (\\n            address _l1TxOrigin\\n        )\\n    {\\n        return transactionContext.ovmL1TXORIGIN;\\n    }\\n\\n    /********************\\n     * Opcodes: Halting *\\n     ********************/\\n\\n    /**\\n     * @notice Overrides REVERT.\\n     * @param _data Bytes data to pass along with the REVERT.\\n     */\\n    function ovmREVERT(\\n        bytes memory _data\\n    )\\n        override\\n        public\\n    {\\n        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);\\n    }\\n\\n\\n    /******************************\\n     * Opcodes: Contract Creation *\\n     ******************************/\\n\\n    /**\\n     * @notice Overrides CREATE.\\n     * @param _bytecode Code to be used to CREATE a new contract.\\n     * @return _contract Address of the created contract.\\n     */\\n    function ovmCREATE(\\n        bytes memory _bytecode\\n    )\\n        override\\n        public\\n        notStatic\\n        fixedGasDiscount(40000)\\n        returns (\\n            address _contract\\n        )\\n    {\\n        // Creator is always the current ADDRESS.\\n        address creator = ovmADDRESS();\\n\\n        // Check that the deployer is whitelisted, or\\n        // that arbitrary contract deployment has been enabled.\\n        _checkDeployerAllowed(creator);\\n\\n        // Generate the correct CREATE address.\\n        address contractAddress = Lib_EthUtils.getAddressForCREATE(\\n            creator,\\n            _getAccountNonce(creator)\\n        );\\n\\n        return _createContract(\\n            contractAddress,\\n            _bytecode\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides CREATE2.\\n     * @param _bytecode Code to be used to CREATE2 a new contract.\\n     * @param _salt Value used to determine the contract's address.\\n     * @return _contract Address of the created contract.\\n     */\\n    function ovmCREATE2(\\n        bytes memory _bytecode,\\n        bytes32 _salt\\n    )\\n        override\\n        public\\n        notStatic\\n        fixedGasDiscount(40000)\\n        returns (\\n            address _contract\\n        )\\n    {\\n        // Creator is always the current ADDRESS.\\n        address creator = ovmADDRESS();\\n\\n        // Check that the deployer is whitelisted, or\\n        // that arbitrary contract deployment has been enabled.\\n        _checkDeployerAllowed(creator);\\n\\n        // Generate the correct CREATE2 address.\\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\\n            creator,\\n            _bytecode,\\n            _salt\\n        );\\n\\n        return _createContract(\\n            contractAddress,\\n            _bytecode\\n        );\\n    }\\n\\n\\n    /*******************************\\n     * Account Abstraction Opcodes *\\n     ******************************/\\n\\n    /**\\n     * Retrieves the nonce of the current ovmADDRESS.\\n     * @return _nonce Nonce of the current contract.\\n     */\\n    function ovmGETNONCE()\\n        override\\n        public\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        return _getAccountNonce(ovmADDRESS());\\n    }\\n\\n    /**\\n     * Sets the nonce of the current ovmADDRESS.\\n     * @param _nonce New nonce for the current contract.\\n     */\\n    function ovmSETNONCE(\\n        uint256 _nonce\\n    )\\n        override\\n        public\\n        notStatic\\n    {\\n        _setAccountNonce(ovmADDRESS(), _nonce);\\n    }\\n\\n    /**\\n     * Creates a new EOA contract account, for account abstraction.\\n     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks\\n     *      because the contract we're creating is trusted (no need to do safety checking or to\\n     *      handle unexpected reverts). Doesn't need to return an address because the address is\\n     *      assumed to be the user's actual address.\\n     * @param _messageHash Hash of a message signed by some user, for verification.\\n     * @param _v Signature `v` parameter.\\n     * @param _r Signature `r` parameter.\\n     * @param _s Signature `s` parameter.\\n     */\\n    function ovmCREATEEOA(\\n        bytes32 _messageHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        override\\n        public\\n        notStatic\\n    {\\n        // Recover the EOA address from the message hash and signature parameters. Since we do the\\n        // hashing in advance, we don't have handle different message hashing schemes. Even if this\\n        // function were to return the wrong address (rather than explicitly returning the zero\\n        // address), the rest of the transaction would simply fail (since there's no EOA account to\\n        // actually execute the transaction).\\n        address eoa = ecrecover(\\n            _messageHash,\\n            _v + 27,\\n            _r,\\n            _s\\n        );\\n\\n        // Invalid signature is a case we proactively handle with a revert. We could alternatively\\n        // have this function return a `success` boolean, but this is just easier.\\n        if (eoa == address(0)) {\\n            ovmREVERT(bytes(\\\"Signature provided for EOA contract creation is invalid.\\\"));\\n        }\\n\\n        // If the user already has an EOA account, then there's no need to perform this operation.\\n        if (_hasEmptyAccount(eoa) == false) {\\n            return;\\n        }\\n\\n        // We always need to initialize the contract with the default account values.\\n        _initPendingAccount(eoa);\\n\\n        // Temporarily set the current address so it's easier to access on L2.\\n        address prevADDRESS = messageContext.ovmADDRESS;\\n        messageContext.ovmADDRESS = eoa;\\n\\n        // Now actually create the account and get its bytecode. We're not worried about reverts\\n        // (other than out of gas, which we can't capture anyway) because this contract is trusted.\\n        OVM_ProxyEOA proxyEOA = new OVM_ProxyEOA(0x4200000000000000000000000000000000000003);\\n\\n        // Reset the address now that we're done deploying.\\n        messageContext.ovmADDRESS = prevADDRESS;\\n\\n        // Commit the account with its final values.\\n        _commitPendingAccount(\\n            eoa,\\n            address(proxyEOA),\\n            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))\\n        );\\n\\n        _setAccountNonce(eoa, 0);\\n    }\\n\\n\\n    /*********************************\\n     * Opcodes: Contract Interaction *\\n     *********************************/\\n\\n    /**\\n     * @notice Overrides CALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmCALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(100000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // CALL updates the CALLER and ADDRESS.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _address;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides STATICCALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmSTATICCALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(80000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static context.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _address;\\n        nextMessageContext.isStatic = true;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides DELEGATECALL.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _address Address of the contract to call.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function ovmDELEGATECALL(\\n        uint256 _gasLimit,\\n        address _address,\\n        bytes memory _calldata\\n    )\\n        override\\n        public\\n        fixedGasDiscount(40000)\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // DELEGATECALL does not change anything about the message context.\\n        MessageContext memory nextMessageContext = messageContext;\\n        bool isStaticEntrypoint = false;\\n\\n        return _callContract(\\n            nextMessageContext,\\n            _gasLimit,\\n            _address,\\n            _calldata\\n        );\\n    }\\n\\n\\n    /************************************\\n     * Opcodes: Contract Storage Access *\\n     ************************************/\\n\\n    /**\\n     * @notice Overrides SLOAD.\\n     * @param _key 32 byte key of the storage slot to load.\\n     * @return _value 32 byte value of the requested storage slot.\\n     */\\n    function ovmSLOAD(\\n        bytes32 _key\\n    )\\n        override\\n        public\\n        netGasCost(40000)\\n        returns (\\n            bytes32 _value\\n        )\\n    {\\n        // We always SLOAD from the storage of ADDRESS.\\n        address contractAddress = ovmADDRESS();\\n\\n        return _getContractStorage(\\n            contractAddress,\\n            _key\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides SSTORE.\\n     * @param _key 32 byte key of the storage slot to set.\\n     * @param _value 32 byte value for the storage slot.\\n     */\\n    function ovmSSTORE(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        override\\n        public\\n        notStatic\\n        netGasCost(60000)\\n    {\\n        // We always SSTORE to the storage of ADDRESS.\\n        address contractAddress = ovmADDRESS();\\n\\n        _putContractStorage(\\n            contractAddress,\\n            _key,\\n            _value\\n        );\\n    }\\n\\n\\n    /*********************************\\n     * Opcodes: Contract Code Access *\\n     *********************************/\\n\\n    /**\\n     * @notice Overrides EXTCODECOPY.\\n     * @param _contract Address of the contract to copy code from.\\n     * @param _offset Offset in bytes from the start of contract code to copy beyond.\\n     * @param _length Total number of bytes to copy from the contract's code.\\n     * @return _code Bytes of code copied from the requested contract.\\n     */\\n    function ovmEXTCODECOPY(\\n        address _contract,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        override\\n        public\\n        returns (\\n            bytes memory _code\\n        )\\n    {\\n        // `ovmEXTCODECOPY` is the only overridden opcode capable of producing exactly one byte of\\n        // return data. By blocking reads of one byte, we're able to use the condition that an\\n        // OVM_ExecutionManager function return value having a length of exactly one byte indicates\\n        // an error without an explicit revert. If users were able to read a single byte, they\\n        // could forcibly trigger behavior that should only be available to this contract.\\n        uint256 length = _length == 1 ? 2 : _length;\\n\\n        return Lib_EthUtils.getCode(\\n            _getAccountEthAddress(_contract),\\n            _offset,\\n            length\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides EXTCODESIZE.\\n     * @param _contract Address of the contract to query the size of.\\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\\n     */\\n    function ovmEXTCODESIZE(\\n        address _contract\\n    )\\n        override\\n        public\\n        returns (\\n            uint256 _EXTCODESIZE\\n        )\\n    {\\n        return Lib_EthUtils.getCodeSize(\\n            _getAccountEthAddress(_contract)\\n        );\\n    }\\n\\n    /**\\n     * @notice Overrides EXTCODEHASH.\\n     * @param _contract Address of the contract to query the hash of.\\n     * @return _EXTCODEHASH Hash of the requested contract.\\n     */\\n    function ovmEXTCODEHASH(\\n        address _contract\\n    )\\n        override\\n        public\\n        returns (\\n            bytes32 _EXTCODEHASH\\n        )\\n    {\\n        return Lib_EthUtils.getCodeHash(\\n            _getAccountEthAddress(_contract)\\n        );\\n    }\\n\\n\\n    /**************************************\\n     * Public Functions: Execution Safety *\\n     **************************************/\\n\\n    /**\\n     * Performs the logic to create a contract and revert under various potential conditions.\\n     * @dev This function is implemented as `public` because we need to be able to revert a\\n     *      contract creation without losing information about exactly *why* the contract reverted.\\n     *      In particular, we want to be sure that contracts cannot trigger an INVALID_STATE_ACCESS\\n     *      flag and then revert to reset the flag. We're able to do this by making an external\\n     *      call from `ovmCREATE` and `ovmCREATE2` to `safeCREATE`, which can capture and relay\\n     *      information before reverting.\\n     * @param _address Address of the contract to associate with the one being created.\\n     * @param _bytecode Code to be used to create the new contract.\\n     */\\n    function safeCREATE(\\n        address _address,\\n        bytes memory _bytecode\\n    )\\n        override\\n        public\\n    {\\n        // Since this function is public, anyone can attempt to directly call it. We need to make\\n        // sure that the OVM_ExecutionManager itself is the only party that can actually try to\\n        // call this function.\\n        if (msg.sender != address(this)) {\\n            return;\\n        }\\n\\n        // We need to be sure that the user isn't trying to use a contract creation to overwrite\\n        // some existing contract. On L1, users will prove that no contract exists at the address\\n        // and the OVM_FraudVerifier will populate the code hash of this address with a special\\n        // value that represents \\\"known to be an empty account.\\\"\\n        if (_hasEmptyAccount(_address) == false) {\\n            _revertWithFlag(RevertFlag.CREATE_COLLISION);\\n        }\\n\\n        // Check the creation bytecode against the OVM_SafetyChecker.\\n        if (ovmSafetyChecker.isBytecodeSafe(_bytecode) == false) {\\n            _revertWithFlag(RevertFlag.UNSAFE_BYTECODE);\\n        }\\n\\n        // We always need to initialize the contract with the default account values.\\n        _initPendingAccount(_address);\\n\\n        // Actually deploy the contract and retrieve its address. This step is hiding a lot of\\n        // complexity because we need to ensure that contract creation *never* reverts by itself.\\n        // We cover this partially by storing a revert flag and returning (instead of reverting)\\n        // when we know that we're inside a contract's creation code.\\n        address ethAddress = Lib_EthUtils.createContract(_bytecode);\\n\\n        // Contract creation returns the zero address when it fails, which should only be possible\\n        // if the user intentionally runs out of gas. However, we might still have a bit of gas\\n        // left over since contract calls can only be passed 63/64ths of total gas,  so we need to\\n        // explicitly handle this case here.\\n        if (ethAddress == address(0)) {\\n            _revertWithFlag(RevertFlag.CREATE_EXCEPTION);\\n        }\\n\\n        // Here we pull out the revert flag that would've been set during creation code. Now that\\n        // we're out of creation code again, we can just revert normally while passing the flag\\n        // through the revert data.\\n        if (messageRecord.revertFlag != RevertFlag.DID_NOT_REVERT) {\\n            _revertWithFlag(messageRecord.revertFlag);\\n        }\\n\\n        // Again simply checking that the deployed code is safe too. Contracts can generate\\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\\n            _revertWithFlag(RevertFlag.UNSAFE_BYTECODE);\\n        }\\n\\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\\n        // associating the desired address with the newly created contract's code hash and address.\\n        _commitPendingAccount(\\n            _address,\\n            ethAddress,\\n            Lib_EthUtils.getCodeHash(ethAddress)\\n        );\\n    }\\n\\n\\n    /***************************************\\n     * Public Functions: Execution Context *\\n     ***************************************/\\n\\n    function getMaxTransactionGasLimit()\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 _maxTransactionGasLimit\\n        )\\n    {\\n        return gasMeterConfig.maxTransactionGasLimit;\\n    }\\n\\n    /********************************************\\n     * Public Functions: Deployment Witelisting *\\n     ********************************************/\\n\\n    /**\\n     * Checks whether the given address is on the whitelst to ovmCREATE/ovmCREATE2, and reverts if not.\\n     * @param _deployerAddress Address attempting to deploy a contract.\\n     */\\n    function _checkDeployerAllowed(\\n        address _deployerAddress\\n    )\\n        internal\\n    {\\n        // From an OVM semanitcs perspectibe, this will appear the identical to\\n        // the deployer ovmCALLing the whitelist.  This is fine--in a sense, we are forcing them to.\\n        (bool success, bytes memory data) = ovmCALL(\\n            gasleft(),\\n            0x4200000000000000000000000000000000000002,\\n            abi.encodeWithSignature(\\\"isDeployerAllowed(address)\\\", _deployerAddress)\\n        );\\n        bool isAllowed = abi.decode(data, (bool));\\n\\n        if (!isAllowed || !success) {\\n            _revertWithFlag(RevertFlag.CREATOR_NOT_ALLOWED);\\n        }\\n    }\\n\\n    /********************************************\\n     * Internal Functions: Contract Interaction *\\n     ********************************************/\\n\\n    /**\\n     * Creates a new contract and associates it with some contract address.\\n     * @param _contractAddress Address to associate the created contract with.\\n     * @param _bytecode Bytecode to be used to create the contract.\\n     * @return _created Final OVM contract address.\\n     */\\n    function _createContract(\\n        address _contractAddress,\\n        bytes memory _bytecode\\n    )\\n        internal\\n        returns (\\n            address _created\\n        )\\n    {\\n        // We always update the nonce of the creating account, even if the creation fails.\\n        _setAccountNonce(ovmADDRESS(), _getAccountNonce(ovmADDRESS()) + 1);\\n\\n        // We're stepping into a CREATE or CREATE2, so we need to update ADDRESS to point\\n        // to the contract's associated address and CALLER to point to the previous ADDRESS.\\n        MessageContext memory nextMessageContext = messageContext;\\n        nextMessageContext.ovmCALLER = messageContext.ovmADDRESS;\\n        nextMessageContext.ovmADDRESS = _contractAddress;\\n\\n        // Run `safeCREATE` in a new EVM message so that our changes can be reflected even if\\n        // `safeCREATE` reverts.\\n        (bool _success, ) = _handleExternalInteraction(\\n            nextMessageContext,\\n            gasleft(),\\n            address(this),\\n            abi.encodeWithSignature(\\n                \\\"safeCREATE(address,bytes)\\\",\\n                _contractAddress,\\n                _bytecode\\n            )\\n        );\\n\\n        // Need to make sure that this flag is reset so that it isn't propagated to creations in\\n        // some parent EVM message.\\n        messageRecord.revertFlag = RevertFlag.DID_NOT_REVERT;\\n\\n        // Yellow paper requires that address returned is zero if the contract deployment fails.\\n        return _success ? _contractAddress : address(0);\\n    }\\n\\n    /**\\n     * Calls the deployed contract associated with a given address.\\n     * @param _nextMessageContext Message context to be used for the call.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _contract OVM address to be called.\\n     * @param _calldata Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function _callContract(\\n        MessageContext memory _nextMessageContext,\\n        uint256 _gasLimit,\\n        address _contract,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // We reserve addresses of the form 0xdeaddeaddead...NNNN for the container contracts in L2 geth.\\n        // So, we block calls to these addresses since they are not safe to run as an OVM contract itself.\\n        if (\\n            (uint256(_contract) & uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000))\\n            == uint256(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000)\\n        ) {\\n            return (true, hex'');\\n        }\\n\\n        // Both 0x0000... and the EVM precompiles have the same address on L1 and L2 --> no trie lookup needed.\\n        address codeContractAddress =\\n            uint(_contract) < 100\\n            ? _contract\\n            : _getAccountEthAddress(_contract);\\n\\n        return _handleExternalInteraction(\\n            _nextMessageContext,\\n            _gasLimit,\\n            codeContractAddress,\\n            _calldata\\n        );\\n    }\\n\\n    /**\\n     * Handles the logic of making an external call and parsing revert information.\\n     * @param _nextMessageContext Message context to be used for the call.\\n     * @param _gasLimit Amount of gas to be passed into this call.\\n     * @param _target Address of the contract to call.\\n     * @param _data Data to send along with the call.\\n     * @return _success Whether or not the call returned (rather than reverted).\\n     * @return _returndata Data returned by the call.\\n     */\\n    function _handleExternalInteraction(\\n        MessageContext memory _nextMessageContext,\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _data\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        // We need to switch over to our next message context for the duration of this call.\\n        MessageContext memory prevMessageContext = messageContext;\\n        _switchMessageContext(prevMessageContext, _nextMessageContext);\\n\\n        // Nuisance gas is a system used to bound the ability for an attacker to make fraud proofs\\n        // expensive by touching a lot of different accounts or storage slots. Since most contracts\\n        // only use a few storage slots during any given transaction, this shouldn't be a limiting\\n        // factor.\\n        uint256 prevNuisanceGasLeft = messageRecord.nuisanceGasLeft;\\n        uint256 nuisanceGasLimit = _getNuisanceGasLimit(_gasLimit);\\n        messageRecord.nuisanceGasLeft = nuisanceGasLimit;\\n\\n        // Make the call and make sure to pass in the gas limit. Another instance of hidden\\n        // complexity. `_target` is guaranteed to be a safe contract, meaning its return/revert\\n        // behavior can be controlled. In particular, we enforce that flags are passed through\\n        // revert data as to retrieve execution metadata that would normally be reverted out of\\n        // existence.\\n        (bool success, bytes memory returndata) = _target.call{gas: _gasLimit}(_data);\\n\\n        // Switch back to the original message context now that we're out of the call.\\n        _switchMessageContext(_nextMessageContext, prevMessageContext);\\n\\n        // Assuming there were no reverts, the message record should be accurate here. We'll update\\n        // this value in the case of a revert.\\n        uint256 nuisanceGasLeft = messageRecord.nuisanceGasLeft;\\n\\n        // Reverts at this point are completely OK, but we need to make a few updates based on the\\n        // information passed through the revert.\\n        if (success == false) {\\n            (\\n                RevertFlag flag,\\n                uint256 nuisanceGasLeftPostRevert,\\n                uint256 ovmGasRefund,\\n                bytes memory returndataFromFlag\\n            ) = _decodeRevertData(returndata);\\n\\n            // INVALID_STATE_ACCESS is the only flag that triggers an immediate abort of the\\n            // parent EVM message. This behavior is necessary because INVALID_STATE_ACCESS must\\n            // halt any further transaction execution that could impact the execution result.\\n            if (flag == RevertFlag.INVALID_STATE_ACCESS) {\\n                _revertWithFlag(flag);\\n            }\\n\\n            // INTENTIONAL_REVERT, UNSAFE_BYTECODE, STATIC_VIOLATION, and CREATOR_NOT_ALLOWED aren't\\n            // dependent on the input state, so we can just handle them like standard reverts. Our only change here\\n            // is to record the gas refund reported by the call (enforced by safety checking).\\n            if (\\n                flag == RevertFlag.INTENTIONAL_REVERT\\n                || flag == RevertFlag.UNSAFE_BYTECODE\\n                || flag == RevertFlag.STATIC_VIOLATION\\n                || flag == RevertFlag.CREATOR_NOT_ALLOWED\\n            ) {\\n                transactionRecord.ovmGasRefund = ovmGasRefund;\\n            }\\n\\n            // INTENTIONAL_REVERT needs to pass up the user-provided return data encoded into the\\n            // flag, *not* the full encoded flag. All other revert types return no data.\\n            if (flag == RevertFlag.INTENTIONAL_REVERT) {\\n                returndata = returndataFromFlag;\\n            } else {\\n                returndata = hex'';\\n            }\\n\\n            // Reverts mean we need to use up whatever \\\"nuisance gas\\\" was used by the call.\\n            // EXCEEDS_NUISANCE_GAS explicitly reduces the remaining nuisance gas for this message\\n            // to zero. OUT_OF_GAS is a \\\"pseudo\\\" flag given that messages return no data when they\\n            // run out of gas, so we have to treat this like EXCEEDS_NUISANCE_GAS. All other flags\\n            // will simply pass up the remaining nuisance gas.\\n            nuisanceGasLeft = nuisanceGasLeftPostRevert;\\n        }\\n\\n        // We need to reset the nuisance gas back to its original value minus the amount used here.\\n        messageRecord.nuisanceGasLeft = prevNuisanceGasLeft - (nuisanceGasLimit - nuisanceGasLeft);\\n\\n        return (\\n            success,\\n            returndata\\n        );\\n    }\\n\\n\\n    /******************************************\\n     * Internal Functions: State Manipulation *\\n     ******************************************/\\n\\n    /**\\n     * Checks whether an account exists within the OVM_StateManager.\\n     * @param _address Address of the account to check.\\n     * @return _exists Whether or not the account exists.\\n     */\\n    function _hasAccount(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            bool _exists\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return ovmStateManager.hasAccount(_address);\\n    }\\n\\n    /**\\n     * Checks whether a known empty account exists within the OVM_StateManager.\\n     * @param _address Address of the account to check.\\n     * @return _exists Whether or not the account empty exists.\\n     */\\n    function _hasEmptyAccount(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            bool _exists\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return ovmStateManager.hasEmptyAccount(_address);\\n    }\\n\\n    /**\\n     * Sets the nonce of an account.\\n     * @param _address Address of the account to modify.\\n     * @param _nonce New account nonce.\\n     */\\n    function _setAccountNonce(\\n        address _address,\\n        uint256 _nonce\\n    )\\n        internal\\n    {\\n        _checkAccountChange(_address);\\n        ovmStateManager.setAccountNonce(_address, _nonce);\\n    }\\n\\n    /**\\n     * Gets the nonce of an account.\\n     * @param _address Address of the account to access.\\n     * @return _nonce Nonce of the account.\\n     */\\n    function _getAccountNonce(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return ovmStateManager.getAccountNonce(_address);\\n    }\\n\\n    /**\\n     * Retrieves the Ethereum address of an account.\\n     * @param _address Address of the account to access.\\n     * @return _ethAddress Corresponding Ethereum address.\\n     */\\n    function _getAccountEthAddress(\\n        address _address\\n    )\\n        internal\\n        returns (\\n            address _ethAddress\\n        )\\n    {\\n        _checkAccountLoad(_address);\\n        return ovmStateManager.getAccountEthAddress(_address);\\n    }\\n\\n    /**\\n     * Creates the default account object for the given address.\\n     * @param _address Address of the account create.\\n     */\\n    function _initPendingAccount(\\n        address _address\\n    )\\n        internal\\n    {\\n        // Although it seems like `_checkAccountChange` would be more appropriate here, we don't\\n        // actually consider an account \\\"changed\\\" until it's inserted into the state (in this case\\n        // by `_commitPendingAccount`).\\n        _checkAccountLoad(_address);\\n        ovmStateManager.initPendingAccount(_address);\\n    }\\n\\n    /**\\n     * Stores additional relevant data for a new account, thereby \\\"committing\\\" it to the state.\\n     * This function is only called during `ovmCREATE` and `ovmCREATE2` after a successful contract\\n     * creation.\\n     * @param _address Address of the account to commit.\\n     * @param _ethAddress Address of the associated deployed contract.\\n     * @param _codeHash Hash of the code stored at the address.\\n     */\\n    function _commitPendingAccount(\\n        address _address,\\n        address _ethAddress,\\n        bytes32 _codeHash\\n    )\\n        internal\\n    {\\n        _checkAccountChange(_address);\\n        ovmStateManager.commitPendingAccount(\\n            _address,\\n            _ethAddress,\\n            _codeHash\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the value of a storage slot.\\n     * @param _contract Address of the contract to query.\\n     * @param _key 32 byte key of the storage slot.\\n     * @return _value 32 byte storage slot value.\\n     */\\n    function _getContractStorage(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n        returns (\\n            bytes32 _value\\n        )\\n    {\\n        _checkContractStorageLoad(_contract, _key);\\n        return ovmStateManager.getContractStorage(_contract, _key);\\n    }\\n\\n    /**\\n     * Sets the value of a storage slot.\\n     * @param _contract Address of the contract to modify.\\n     * @param _key 32 byte key of the storage slot.\\n     * @param _value 32 byte storage slot value.\\n     */\\n    function _putContractStorage(\\n        address _contract,\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        // We don't set storage if the value didn't change. Although this acts as a convenient\\n        // optimization, it's also necessary to avoid the case in which a contract with no storage\\n        // attempts to store the value \\\"0\\\" at any key. Putting this value (and therefore requiring\\n        // that the value be committed into the storage trie after execution) would incorrectly\\n        // modify the storage root.\\n        if (_getContractStorage(_contract, _key) == _value) {\\n            return;\\n        }\\n\\n        _checkContractStorageChange(_contract, _key);\\n        ovmStateManager.putContractStorage(_contract, _key, _value);\\n    }\\n\\n    /**\\n     * Validation whenever a contract needs to be loaded. Checks that the account exists, charges\\n     * nuisance gas if the account hasn't been loaded before.\\n     * @param _address Address of the account to load.\\n     */\\n    function _checkAccountLoad(\\n        address _address\\n    )\\n        internal\\n    {\\n        // See `_checkContractStorageLoad` for more information.\\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n        }\\n\\n        // See `_checkContractStorageLoad` for more information.\\n        if (ovmStateManager.hasAccount(_address) == false) {\\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\\n        }\\n\\n        // Check whether the account has been loaded before and mark it as loaded if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that an account is loaded.\\n        (\\n            bool _wasAccountAlreadyLoaded\\n        ) = ovmStateManager.testAndSetAccountLoaded(_address);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge \\\"nuisance gas\\\" based\\n        // on the size of the contract code.\\n        if (_wasAccountAlreadyLoaded == false) {\\n            _useNuisanceGas(\\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a contract needs to be changed. Checks that the account exists, charges\\n     * nuisance gas if the account hasn't been changed before.\\n     * @param _address Address of the account to change.\\n     */\\n    function _checkAccountChange(\\n        address _address\\n    )\\n        internal\\n    {\\n        // Start by checking for a load as we only want to charge nuisance gas proportional to\\n        // contract size once.\\n        _checkAccountLoad(_address);\\n\\n        // Check whether the account has been changed before and mark it as changed if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that an account is changed.\\n        (\\n            bool _wasAccountAlreadyChanged\\n        ) = ovmStateManager.testAndSetAccountChanged(_address);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge \\\"nuisance gas\\\" based\\n        // on the size of the contract code.\\n        if (_wasAccountAlreadyChanged == false) {\\n            ovmStateManager.incrementTotalUncommittedAccounts();\\n            _useNuisanceGas(\\n                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a slot needs to be loaded. Checks that the account exists, charges\\n     * nuisance gas if the slot hasn't been loaded before.\\n     * @param _contract Address of the account to load from.\\n     * @param _key 32 byte key to load.\\n     */\\n    function _checkContractStorageLoad(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n    {\\n        // Another case of hidden complexity. If we didn't enforce this requirement, then a\\n        // contract could pass in just enough gas to cause the INVALID_STATE_ACCESS check to fail\\n        // on L1 but not on L2. A contract could use this behavior to prevent the\\n        // OVM_ExecutionManager from detecting an invalid state access. Reverting with OUT_OF_GAS\\n        // allows us to also charge for the full message nuisance gas, because you deserve that for\\n        // trying to break the contract in this way.\\n        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {\\n            _revertWithFlag(RevertFlag.OUT_OF_GAS);\\n        }\\n\\n        // We need to make sure that the transaction isn't trying to access storage that hasn't\\n        // been provided to the OVM_StateManager. We'll immediately abort if this is the case.\\n        // We know that we have enough gas to do this check because of the above test.\\n        if (ovmStateManager.hasContractStorage(_contract, _key) == false) {\\n            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);\\n        }\\n\\n        // Check whether the slot has been loaded before and mark it as loaded if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that a slot is loaded.\\n        (\\n            bool _wasContractStorageAlreadyLoaded\\n        ) = ovmStateManager.testAndSetContractStorageLoaded(_contract, _key);\\n\\n        // If we hadn't already loaded the account, then we'll need to charge some fixed amount of\\n        // \\\"nuisance gas\\\".\\n        if (_wasContractStorageAlreadyLoaded == false) {\\n            _useNuisanceGas(NUISANCE_GAS_SLOAD);\\n        }\\n    }\\n\\n    /**\\n     * Validation whenever a slot needs to be changed. Checks that the account exists, charges\\n     * nuisance gas if the slot hasn't been changed before.\\n     * @param _contract Address of the account to change.\\n     * @param _key 32 byte key to change.\\n     */\\n    function _checkContractStorageChange(\\n        address _contract,\\n        bytes32 _key\\n    )\\n        internal\\n    {\\n        // Start by checking for load to make sure we have the storage slot and that we charge the\\n        // \\\"nuisance gas\\\" necessary to prove the storage slot state.\\n        _checkContractStorageLoad(_contract, _key);\\n\\n        // Check whether the slot has been changed before and mark it as changed if not. We need\\n        // this because \\\"nuisance gas\\\" only applies to the first time that a slot is changed.\\n        (\\n            bool _wasContractStorageAlreadyChanged\\n        ) = ovmStateManager.testAndSetContractStorageChanged(_contract, _key);\\n\\n        // If we hadn't already changed the account, then we'll need to charge some fixed amount of\\n        // \\\"nuisance gas\\\".\\n        if (_wasContractStorageAlreadyChanged == false) {\\n            // Changing a storage slot means that we're also going to have to change the\\n            // corresponding account, so do an account change check.\\n            _checkAccountChange(_contract);\\n\\n            ovmStateManager.incrementTotalUncommittedContractStorage();\\n            _useNuisanceGas(NUISANCE_GAS_SSTORE);\\n        }\\n    }\\n\\n\\n    /************************************\\n     * Internal Functions: Revert Logic *\\n     ************************************/\\n\\n    /**\\n     * Simple encoding for revert data.\\n     * @param _flag Flag to revert with.\\n     * @param _data Additional user-provided revert data.\\n     * @return _revertdata Encoded revert data.\\n     */\\n    function _encodeRevertData(\\n        RevertFlag _flag,\\n        bytes memory _data\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory _revertdata\\n        )\\n    {\\n        // Out of gas and create exceptions will fundamentally return no data, so simulating it shouldn't either.\\n        if (\\n            _flag == RevertFlag.OUT_OF_GAS\\n            || _flag == RevertFlag.CREATE_EXCEPTION\\n        ) {\\n            return bytes('');\\n        }\\n\\n        // INVALID_STATE_ACCESS doesn't need to return any data other than the flag.\\n        if (_flag == RevertFlag.INVALID_STATE_ACCESS) {\\n            return abi.encode(\\n                _flag,\\n                0,\\n                0,\\n                bytes('')\\n            );\\n        }\\n\\n        // Just ABI encode the rest of the parameters.\\n        return abi.encode(\\n            _flag,\\n            messageRecord.nuisanceGasLeft,\\n            transactionRecord.ovmGasRefund,\\n            _data\\n        );\\n    }\\n\\n    /**\\n     * Simple decoding for revert data.\\n     * @param _revertdata Revert data to decode.\\n     * @return _flag Flag used to revert.\\n     * @return _nuisanceGasLeft Amount of nuisance gas unused by the message.\\n     * @return _ovmGasRefund Amount of gas refunded during the message.\\n     * @return _data Additional user-provided revert data.\\n     */\\n    function _decodeRevertData(\\n        bytes memory _revertdata\\n    )\\n        internal\\n        pure\\n        returns (\\n            RevertFlag _flag,\\n            uint256 _nuisanceGasLeft,\\n            uint256 _ovmGasRefund,\\n            bytes memory _data\\n        )\\n    {\\n        // A length of zero means the call ran out of gas, just return empty data.\\n        if (_revertdata.length == 0) {\\n            return (\\n                RevertFlag.OUT_OF_GAS,\\n                0,\\n                0,\\n                bytes('')\\n            );\\n        }\\n\\n        // ABI decode the incoming data.\\n        return abi.decode(_revertdata, (RevertFlag, uint256, uint256, bytes));\\n    }\\n\\n    /**\\n     * Causes a message to revert or abort.\\n     * @param _flag Flag to revert with.\\n     * @param _data Additional user-provided data.\\n     */\\n    function _revertWithFlag(\\n        RevertFlag _flag,\\n        bytes memory _data\\n    )\\n        internal\\n    {\\n        // We don't want to revert when we're inside a CREATE or CREATE2, because those opcodes\\n        // fail silently (we can't pass any data upwards). Instead, we set a flag and return a\\n        // *single* byte, something the OVM_ExecutionManager will not return in any other case.\\n        // We're thereby allowed to communicate failure without allowing contracts to trick us into\\n        // thinking there was a failure.\\n        bool isCreation;\\n        assembly {\\n            isCreation := eq(extcodesize(caller()), 0)\\n        }\\n\\n        if (isCreation) {\\n            messageRecord.revertFlag = _flag;\\n\\n            assembly {\\n                return(0, 1)\\n            }\\n        }\\n\\n        // If we're not inside a CREATE or CREATE2, we can simply encode the necessary data and\\n        // revert normally.\\n        bytes memory revertdata = _encodeRevertData(\\n            _flag,\\n            _data\\n        );\\n\\n        assembly {\\n            revert(add(revertdata, 0x20), mload(revertdata))\\n        }\\n    }\\n\\n    /**\\n     * Causes a message to revert or abort.\\n     * @param _flag Flag to revert with.\\n     */\\n    function _revertWithFlag(\\n        RevertFlag _flag\\n    )\\n        internal\\n    {\\n        _revertWithFlag(_flag, bytes(''));\\n    }\\n\\n\\n    /******************************************\\n     * Internal Functions: Nuisance Gas Logic *\\n     ******************************************/\\n\\n    /**\\n     * Computes the nuisance gas limit from the gas limit.\\n     * @dev This function is currently using a naive implementation whereby the nuisance gas limit\\n     *      is set to exactly equal the lesser of the gas limit or remaining gas. It's likely that\\n     *      this implementation is perfectly fine, but we may change this formula later.\\n     * @param _gasLimit Gas limit to compute from.\\n     * @return _nuisanceGasLimit Computed nuisance gas limit.\\n     */\\n    function _getNuisanceGasLimit(\\n        uint256 _gasLimit\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 _nuisanceGasLimit\\n        )\\n    {\\n        return _gasLimit < gasleft() ? _gasLimit : gasleft();\\n    }\\n\\n    /**\\n     * Uses a certain amount of nuisance gas.\\n     * @param _amount Amount of nuisance gas to use.\\n     */\\n    function _useNuisanceGas(\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        // Essentially the same as a standard OUT_OF_GAS, except we also retain a record of the gas\\n        // refund to be given at the end of the transaction.\\n        if (messageRecord.nuisanceGasLeft < _amount) {\\n            _revertWithFlag(RevertFlag.EXCEEDS_NUISANCE_GAS);\\n        }\\n\\n        messageRecord.nuisanceGasLeft -= _amount;\\n    }\\n\\n\\n    /************************************\\n     * Internal Functions: Gas Metering *\\n     ************************************/\\n\\n    /**\\n     * Checks whether a transaction needs to start a new epoch and does so if necessary.\\n     * @param _timestamp Transaction timestamp.\\n     */\\n    function _checkNeedsNewEpoch(\\n        uint256 _timestamp\\n    )\\n        internal\\n    {\\n        if (\\n            _timestamp >= (\\n                _getGasMetadata(GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP)\\n                + gasMeterConfig.secondsPerEpoch\\n            )\\n        ) {\\n            _putGasMetadata(\\n                GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP,\\n                _timestamp\\n            );\\n\\n            _putGasMetadata(\\n                GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS,\\n                _getGasMetadata(\\n                    GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS\\n                )\\n            );\\n\\n            _putGasMetadata(\\n                GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS,\\n                _getGasMetadata(\\n                    GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Validates the gas limit for a given transaction.\\n     * @param _gasLimit Gas limit provided by the transaction.\\n     * @param _queueOrigin Queue from which the transaction originated.\\n     * @return _valid Whether or not the gas limit is valid.\\n     */\\n    function _isValidGasLimit(\\n        uint256 _gasLimit,\\n        Lib_OVMCodec.QueueOrigin _queueOrigin\\n    )\\n        internal\\n        returns (\\n            bool _valid\\n        )\\n    {\\n        // Always have to be below the maximum gas limit.\\n        if (_gasLimit > gasMeterConfig.maxTransactionGasLimit) {\\n            return false;\\n        }\\n\\n        // Always have to be above the minimum gas limit.\\n        if (_gasLimit < gasMeterConfig.minTransactionGasLimit) {\\n            return false;\\n        }\\n\\n        // TEMPORARY: Gas metering is disabled for minnet.\\n        return true;\\n        // GasMetadataKey cumulativeGasKey;\\n        // GasMetadataKey prevEpochGasKey;\\n        // if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS;\\n        // } else {\\n        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\\n        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS;\\n        // }\\n\\n        // return (\\n        //     (\\n        //         _getGasMetadata(cumulativeGasKey)\\n        //         - _getGasMetadata(prevEpochGasKey)\\n        //         + _gasLimit\\n        //     ) < gasMeterConfig.maxGasPerQueuePerEpoch\\n        // );\\n    }\\n\\n    /**\\n     * Updates the cumulative gas after a transaction.\\n     * @param _gasUsed Gas used by the transaction.\\n     * @param _queueOrigin Queue from which the transaction originated.\\n     */\\n    function _updateCumulativeGas(\\n        uint256 _gasUsed,\\n        Lib_OVMCodec.QueueOrigin _queueOrigin\\n    )\\n        internal\\n    {\\n        GasMetadataKey cumulativeGasKey;\\n        if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {\\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;\\n        } else {\\n            cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;\\n        }\\n\\n        _putGasMetadata(\\n            cumulativeGasKey,\\n            (\\n                _getGasMetadata(cumulativeGasKey)\\n                + gasMeterConfig.minTransactionGasLimit\\n                + _gasUsed\\n                - transactionRecord.ovmGasRefund\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the value of a gas metadata key.\\n     * @param _key Gas metadata key to retrieve.\\n     * @return _value Value stored at the given key.\\n     */\\n    function _getGasMetadata(\\n        GasMetadataKey _key\\n    )\\n        internal\\n        returns (\\n            uint256 _value\\n        )\\n    {\\n        return uint256(_getContractStorage(\\n            GAS_METADATA_ADDRESS,\\n            bytes32(uint256(_key))\\n        ));\\n    }\\n\\n    /**\\n     * Sets the value of a gas metadata key.\\n     * @param _key Gas metadata key to set.\\n     * @param _value Value to store at the given key.\\n     */\\n    function _putGasMetadata(\\n        GasMetadataKey _key,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _putContractStorage(\\n            GAS_METADATA_ADDRESS,\\n            bytes32(uint256(_key)),\\n            bytes32(uint256(_value))\\n        );\\n    }\\n\\n\\n    /*****************************************\\n     * Internal Functions: Execution Context *\\n     *****************************************/\\n\\n    /**\\n     * Swaps over to a new message context.\\n     * @param _prevMessageContext Context we're switching from.\\n     * @param _nextMessageContext Context we're switching to.\\n     */\\n    function _switchMessageContext(\\n        MessageContext memory _prevMessageContext,\\n        MessageContext memory _nextMessageContext\\n    )\\n        internal\\n    {\\n        // Avoid unnecessary the SSTORE.\\n        if (_prevMessageContext.ovmCALLER != _nextMessageContext.ovmCALLER) {\\n            messageContext.ovmCALLER = _nextMessageContext.ovmCALLER;\\n        }\\n\\n        // Avoid unnecessary the SSTORE.\\n        if (_prevMessageContext.ovmADDRESS != _nextMessageContext.ovmADDRESS) {\\n            messageContext.ovmADDRESS = _nextMessageContext.ovmADDRESS;\\n        }\\n\\n        // Avoid unnecessary the SSTORE.\\n        if (_prevMessageContext.isStatic != _nextMessageContext.isStatic) {\\n            messageContext.isStatic = _nextMessageContext.isStatic;\\n        }\\n    }\\n\\n    /**\\n     * Initializes the execution context.\\n     * @param _transaction OVM transaction being executed.\\n     */\\n    function _initContext(\\n        Lib_OVMCodec.Transaction memory _transaction\\n    )\\n        internal\\n    {\\n        transactionContext.ovmTIMESTAMP = _transaction.timestamp;\\n        transactionContext.ovmNUMBER = _transaction.blockNumber;\\n        transactionContext.ovmTXGASLIMIT = _transaction.gasLimit;\\n        transactionContext.ovmL1QUEUEORIGIN = _transaction.l1QueueOrigin;\\n        transactionContext.ovmL1TXORIGIN = _transaction.l1TxOrigin;\\n        transactionContext.ovmGASLIMIT = gasMeterConfig.maxGasPerQueuePerEpoch;\\n\\n        messageRecord.nuisanceGasLeft = _getNuisanceGasLimit(_transaction.gasLimit);\\n    }\\n\\n    /**\\n     * Resets the transaction and message context.\\n     */\\n    function _resetContext()\\n        internal\\n    {\\n        transactionContext.ovmL1TXORIGIN = address(0);\\n        transactionContext.ovmTIMESTAMP = 0;\\n        transactionContext.ovmNUMBER = 0;\\n        transactionContext.ovmGASLIMIT = 0;\\n        transactionContext.ovmTXGASLIMIT = 0;\\n        transactionContext.ovmL1QUEUEORIGIN = Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE;\\n\\n        transactionRecord.ovmGasRefund = 0;\\n\\n        messageContext.ovmCALLER = address(0);\\n        messageContext.ovmADDRESS = address(0);\\n        messageContext.isStatic = false;\\n\\n        messageRecord.nuisanceGasLeft = 0;\\n        messageRecord.revertFlag = RevertFlag.DID_NOT_REVERT;\\n    }\\n\\n    /*****************************\\n     * L2-only Helper Functions *\\n     *****************************/\\n\\n    /**\\n     * Unreachable helper function for simulating eth_calls with an OVM message context.\\n     * This function will throw an exception in all cases other than when used as a custom entrypoint in L2 Geth to simulate eth_call.\\n     * @param _transaction the message transaction to simulate.\\n     * @param _from the OVM account the simulated call should be from.\\n     */\\n    function simulateMessage(\\n        Lib_OVMCodec.Transaction memory _transaction,\\n        address _from,\\n        iOVM_StateManager _ovmStateManager\\n    )\\n        external\\n        returns (\\n            bool,\\n            bytes memory\\n        )\\n    {\\n        // Prevent this call from having any effect unless in a custom-set VM frame\\n        require(msg.sender == address(0));\\n\\n        ovmStateManager = _ovmStateManager;\\n        _initContext(_transaction);\\n\\n        messageRecord.nuisanceGasLeft = uint(-1);\\n        messageContext.ovmADDRESS = _transaction.entrypoint;\\n        messageContext.ovmCALLER = _from;\\n\\n        return _transaction.entrypoint.call{gas: _transaction.gasLimit}(_transaction.data);\\n    }\\n}\\n\",\"keccak256\":\"0x5432ac3e92c78d3bc9faf52e4081cd95b4b6d7858ce14636822f1b2c41cfcc43\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/OVM/precompiles/OVM_DeployerWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_Bytes32Utils } from \\\"../../libraries/utils/Lib_Bytes32Utils.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_DeployerWhitelist } from \\\"../../iOVM/precompiles/iOVM_DeployerWhitelist.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title OVM_DeployerWhitelist\\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an \\n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\\n * \\n * Compiler used: solc\\n * Runtime target: OVM\\n */\\ncontract OVM_DeployerWhitelist is iOVM_DeployerWhitelist {\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    bytes32 internal constant KEY_INITIALIZED =                0x0000000000000000000000000000000000000000000000000000000000000010;\\n    bytes32 internal constant KEY_OWNER =                      0x0000000000000000000000000000000000000000000000000000000000000011;\\n    bytes32 internal constant KEY_ALLOW_ARBITRARY_DEPLOYMENT = 0x0000000000000000000000000000000000000000000000000000000000000012;\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n    \\n    /**\\n     * Blocks functions to anyone except the contract owner.\\n     */\\n    modifier onlyOwner() {\\n        address owner = Lib_Bytes32Utils.toAddress(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\\n                KEY_OWNER\\n            )\\n        );\\n\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\\n            Lib_SafeExecutionManagerWrapper.safeCALLER() == owner,\\n            \\\"Function can only be called by the owner of this contract.\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n    \\n    /**\\n     * Initializes the whitelist.\\n     * @param _owner Address of the owner for this contract.\\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\\n     */\\n    function initialize(\\n        address _owner,\\n        bool _allowArbitraryDeployment\\n    )\\n        override\\n        public\\n    {\\n        bool initialized = Lib_Bytes32Utils.toBool(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\\n        );\\n\\n        if (initialized == true) {\\n            return;\\n        }\\n\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            KEY_INITIALIZED,\\n            Lib_Bytes32Utils.fromBool(true)\\n        );\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            KEY_OWNER,\\n            Lib_Bytes32Utils.fromAddress(_owner)\\n        );\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\\n        );\\n    }\\n\\n    /**\\n     * Gets the owner of the whitelist.\\n     */\\n    function getOwner()\\n        override\\n        public\\n        returns(\\n            address\\n        )\\n    {\\n        return Lib_Bytes32Utils.toAddress(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\\n                KEY_OWNER\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Adds or removes an address from the deployment whitelist.\\n     * @param _deployer Address to update permissions for.\\n     * @param _isWhitelisted Whether or not the address is whitelisted.\\n     */\\n    function setWhitelistedDeployer(\\n        address _deployer,\\n        bool _isWhitelisted\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            Lib_Bytes32Utils.fromAddress(_deployer),\\n            Lib_Bytes32Utils.fromBool(_isWhitelisted)\\n        );\\n    }\\n\\n    /**\\n     * Updates the owner of this contract.\\n     * @param _owner Address of the new owner.\\n     */\\n    function setOwner(\\n        address _owner\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            KEY_OWNER,\\n            Lib_Bytes32Utils.fromAddress(_owner)\\n        );\\n    }\\n\\n    /**\\n     * Updates the arbitrary deployment flag.\\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\\n     */\\n    function setAllowArbitraryDeployment(\\n        bool _allowArbitraryDeployment\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\\n        );\\n    }\\n\\n    /**\\n     * Permanently enables arbitrary contract deployment and deletes the owner.\\n     */\\n    function enableArbitraryContractDeployment()\\n        override\\n        public\\n        onlyOwner\\n    {\\n        setAllowArbitraryDeployment(true);\\n        setOwner(address(0));\\n    }\\n\\n    /**\\n     * Checks whether an address is allowed to deploy contracts.\\n     * @param _deployer Address to check.\\n     * @return _allowed Whether or not the address can deploy contracts.\\n     */\\n    function isDeployerAllowed(\\n        address _deployer\\n    )\\n        override\\n        public\\n        returns (\\n            bool _allowed\\n        )\\n    {\\n        bool initialized = Lib_Bytes32Utils.toBool(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\\n        );\\n\\n        if (initialized == false) {\\n            return true;\\n        }\\n\\n        bool allowArbitraryDeployment = Lib_Bytes32Utils.toBool(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_ALLOW_ARBITRARY_DEPLOYMENT)\\n        );\\n\\n        if (allowArbitraryDeployment == true) {\\n            return true;\\n        }\\n\\n        bool isWhitelisted = Lib_Bytes32Utils.toBool(\\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\\n                Lib_Bytes32Utils.fromAddress(_deployer)\\n            )\\n        );\\n\\n        return isWhitelisted;        \\n    }\\n}\\n\",\"keccak256\":\"0x8737cfb9c47bf262eb16b80ca9111e0b347b1fe06c517569907056b8e2f28aaf\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/accounts/iOVM_ECDSAContractAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_ECDSAContractAccount\\n */\\ninterface iOVM_ECDSAContractAccount {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function execute(\\n        bytes memory _transaction,\\n        Lib_OVMCodec.EOASignatureType _signatureType,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external returns (bool _success, bytes memory _returndata);\\n}\\n\",\"keccak256\":\"0x308729bc62dcffb11ff1d840781105cf1bf0dd4cbcfb1af704b800bb0cfe9b85\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\ninterface iOVM_ExecutionManager {\\n    /**********\\n     * Enums *\\n     *********/\\n\\n    enum RevertFlag {\\n        DID_NOT_REVERT,\\n        OUT_OF_GAS,\\n        INTENTIONAL_REVERT,\\n        EXCEEDS_NUISANCE_GAS,\\n        INVALID_STATE_ACCESS,\\n        UNSAFE_BYTECODE,\\n        CREATE_COLLISION,\\n        STATIC_VIOLATION,\\n        CREATE_EXCEPTION,\\n        CREATOR_NOT_ALLOWED\\n    }\\n\\n    enum GasMetadataKey {\\n        CURRENT_EPOCH_START_TIMESTAMP,\\n        CUMULATIVE_SEQUENCER_QUEUE_GAS,\\n        CUMULATIVE_L1TOL2_QUEUE_GAS,\\n        PREV_EPOCH_SEQUENCER_QUEUE_GAS,\\n        PREV_EPOCH_L1TOL2_QUEUE_GAS\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct GasMeterConfig {\\n        uint256 minTransactionGasLimit;\\n        uint256 maxTransactionGasLimit;\\n        uint256 maxGasPerQueuePerEpoch;\\n        uint256 secondsPerEpoch;\\n    }\\n\\n    struct GlobalContext {\\n        uint256 ovmCHAINID;\\n    }\\n\\n    struct TransactionContext {\\n        Lib_OVMCodec.QueueOrigin ovmL1QUEUEORIGIN;\\n        uint256 ovmTIMESTAMP;\\n        uint256 ovmNUMBER;\\n        uint256 ovmGASLIMIT;\\n        uint256 ovmTXGASLIMIT;\\n        address ovmL1TXORIGIN;\\n    }\\n\\n    struct TransactionRecord {\\n        uint256 ovmGasRefund;\\n    }\\n\\n    struct MessageContext {\\n        address ovmCALLER;\\n        address ovmADDRESS;\\n        bool isStatic;\\n    }\\n\\n    struct MessageRecord {\\n        uint256 nuisanceGasLeft;\\n        RevertFlag revertFlag;\\n    }\\n\\n\\n    /************************************\\n     * Transaction Execution Entrypoint *\\n     ************************************/\\n\\n    function run(\\n        Lib_OVMCodec.Transaction calldata _transaction,\\n        address _txStateManager\\n    ) external;\\n\\n\\n    /*******************\\n     * Context Opcodes *\\n     *******************/\\n\\n    function ovmCALLER() external view returns (address _caller);\\n    function ovmADDRESS() external view returns (address _address);\\n    function ovmTIMESTAMP() external view returns (uint256 _timestamp);\\n    function ovmNUMBER() external view returns (uint256 _number);\\n    function ovmGASLIMIT() external view returns (uint256 _gasLimit);\\n    function ovmCHAINID() external view returns (uint256 _chainId);\\n\\n\\n    /**********************\\n     * L2 Context Opcodes *\\n     **********************/\\n\\n    function ovmL1QUEUEORIGIN() external view returns (Lib_OVMCodec.QueueOrigin _queueOrigin);\\n    function ovmL1TXORIGIN() external view returns (address _l1TxOrigin);\\n\\n\\n    /*******************\\n     * Halting Opcodes *\\n     *******************/\\n\\n    function ovmREVERT(bytes memory _data) external;\\n\\n\\n    /*****************************\\n     * Contract Creation Opcodes *\\n     *****************************/\\n\\n    function ovmCREATE(bytes memory _bytecode) external returns (address _contract);\\n    function ovmCREATE2(bytes memory _bytecode, bytes32 _salt) external returns (address _contract);\\n\\n\\n    /*******************************\\n     * Account Abstraction Opcodes *\\n     ******************************/\\n\\n    function ovmGETNONCE() external returns (uint256 _nonce);\\n    function ovmSETNONCE(uint256 _nonce) external;\\n    function ovmCREATEEOA(bytes32 _messageHash, uint8 _v, bytes32 _r, bytes32 _s) external;\\n\\n\\n    /****************************\\n     * Contract Calling Opcodes *\\n     ****************************/\\n\\n    function ovmCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\\n    function ovmSTATICCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\\n    function ovmDELEGATECALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);\\n\\n\\n    /****************************\\n     * Contract Storage Opcodes *\\n     ****************************/\\n\\n    function ovmSLOAD(bytes32 _key) external returns (bytes32 _value);\\n    function ovmSSTORE(bytes32 _key, bytes32 _value) external;\\n\\n\\n    /*************************\\n     * Contract Code Opcodes *\\n     *************************/\\n\\n    function ovmEXTCODECOPY(address _contract, uint256 _offset, uint256 _length) external returns (bytes memory _code);\\n    function ovmEXTCODESIZE(address _contract) external returns (uint256 _size);\\n    function ovmEXTCODEHASH(address _contract) external returns (bytes32 _hash);\\n\\n\\n    /**************************************\\n     * Public Functions: Execution Safety *\\n     **************************************/\\n\\n    function safeCREATE(address _address, bytes memory _bytecode) external;\\n\\n    /***************************************\\n     * Public Functions: Execution Context *\\n     ***************************************/\\n\\n    function getMaxTransactionGasLimit() external view returns (uint _maxTransactionGasLimit);\\n}\\n\",\"keccak256\":\"0xed2ea81fb87874b10ebd34339f0690107a841672941de37b405c2da2c285cff0\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/execution/iOVM_SafetyChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iOVM_SafetyChecker\\n */\\ninterface iOVM_SafetyChecker {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function isBytecodeSafe(bytes calldata _bytecode) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xde6639676d4ec4f77297652d5ede2429bc93e74e11fefd9e9de4bc92dd784878\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/execution/iOVM_StateManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_StateManager\\n */\\ninterface iOVM_StateManager {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum ItemState {\\n        ITEM_UNTOUCHED,\\n        ITEM_LOADED,\\n        ITEM_CHANGED,\\n        ITEM_COMMITTED\\n    }\\n\\n    /***************************\\n     * Public Functions: Misc *\\n     ***************************/\\n\\n    function isAuthenticated(address _address) external view returns (bool);\\n\\n    /***************************\\n     * Public Functions: Setup *\\n     ***************************/\\n\\n    function owner() external view returns (address _owner);\\n    function ovmExecutionManager() external view returns (address _ovmExecutionManager);\\n    function setExecutionManager(address _ovmExecutionManager) external;\\n\\n\\n    /************************************\\n     * Public Functions: Account Access *\\n     ************************************/\\n\\n    function putAccount(address _address, Lib_OVMCodec.Account memory _account) external;\\n    function putEmptyAccount(address _address) external;\\n    function getAccount(address _address) external view returns (Lib_OVMCodec.Account memory _account);\\n    function hasAccount(address _address) external view returns (bool _exists);\\n    function hasEmptyAccount(address _address) external view returns (bool _exists);\\n    function setAccountNonce(address _address, uint256 _nonce) external;\\n    function getAccountNonce(address _address) external view returns (uint256 _nonce);\\n    function getAccountEthAddress(address _address) external view returns (address _ethAddress);\\n    function getAccountStorageRoot(address _address) external view returns (bytes32 _storageRoot);\\n    function initPendingAccount(address _address) external;\\n    function commitPendingAccount(address _address, address _ethAddress, bytes32 _codeHash) external;\\n    function testAndSetAccountLoaded(address _address) external returns (bool _wasAccountAlreadyLoaded);\\n    function testAndSetAccountChanged(address _address) external returns (bool _wasAccountAlreadyChanged);\\n    function commitAccount(address _address) external returns (bool _wasAccountCommitted);\\n    function incrementTotalUncommittedAccounts() external;\\n    function getTotalUncommittedAccounts() external view returns (uint256 _total);\\n    function wasAccountChanged(address _address) external view returns (bool);\\n    function wasAccountCommitted(address _address) external view returns (bool);\\n\\n\\n    /************************************\\n     * Public Functions: Storage Access *\\n     ************************************/\\n\\n    function putContractStorage(address _contract, bytes32 _key, bytes32 _value) external;\\n    function getContractStorage(address _contract, bytes32 _key) external view returns (bytes32 _value);\\n    function hasContractStorage(address _contract, bytes32 _key) external view returns (bool _exists);\\n    function testAndSetContractStorageLoaded(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyLoaded);\\n    function testAndSetContractStorageChanged(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyChanged);\\n    function commitContractStorage(address _contract, bytes32 _key) external returns (bool _wasContractStorageCommitted);\\n    function incrementTotalUncommittedContractStorage() external;\\n    function getTotalUncommittedContractStorage() external view returns (uint256 _total);\\n    function wasContractStorageChanged(address _contract, bytes32 _key) external view returns (bool);\\n    function wasContractStorageCommitted(address _contract, bytes32 _key) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x7a11dbd1f61593ba34debe07e39eef59967307f7f372ba9855bee0953585d08d\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/precompiles/iOVM_DeployerWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iOVM_DeployerWhitelist\\n */\\ninterface iOVM_DeployerWhitelist {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function initialize(address _owner, bool _allowArbitraryDeployment) external;\\n    function getOwner() external returns (address _owner);\\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external;\\n    function setOwner(address _newOwner) external;\\n    function setAllowArbitraryDeployment(bool _allowArbitraryDeployment) external;\\n    function enableArbitraryContractDeployment() external;\\n    function isDeployerAllowed(address _deployer) external returns (bool _allowed);\\n}\\n\",\"keccak256\":\"0x969394371cacfc36493230150b6d629173ea72dfdf729330bede475b91d0f004\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    bytes constant internal RLP_NULL_BYTES = hex'80';\\n    bytes constant internal NULL_BYTES = bytes('');\\n\\n    // Ring buffer IDs\\n    bytes32 constant internal RING_BUFFER_SCC_BATCHES = keccak256(\\\"RING_BUFFER_SCC_BATCHES\\\");\\n    bytes32 constant internal RING_BUFFER_CTC_BATCHES = keccak256(\\\"RING_BUFFER_CTC_BATCHES\\\");\\n    bytes32 constant internal RING_BUFFER_CTC_QUEUE = keccak256(\\\"RING_BUFFER_CTC_QUEUE\\\");\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum EOASignatureType {\\n        EIP155_TRANSACTON,\\n        ETH_SIGNED_MESSAGE\\n    }\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Account {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n        address ethAddress;\\n        bool isFresh;\\n    }\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 queueRoot;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    struct EIP155Transaction {\\n        uint256 nonce;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n\\n    /*********************************************\\n     * Internal Functions: Encoding and Decoding *\\n     *********************************************/\\n\\n    /**\\n     * Decodes an EOA transaction (i.e., native Ethereum RLP encoding).\\n     * @param _transaction Encoded EOA transaction.\\n     * @return _decoded Transaction decoded into a struct.\\n     */\\n    function decodeEIP155Transaction(\\n        bytes memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            EIP155Transaction memory _decoded\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            (\\n                uint256 _nonce,\\n                uint256 _gasLimit,\\n                uint256 _gasPrice,\\n                uint256 _chainId,\\n                address _to,\\n                bytes memory _data\\n            ) = abi.decode(\\n                _transaction,\\n                (uint256, uint256, uint256, uint256, address ,bytes)\\n            );\\n            return EIP155Transaction({\\n                nonce: _nonce,\\n                gasPrice: _gasPrice,\\n                gasLimit: _gasLimit,\\n                to: _to,\\n                value: 0,\\n                data: _data,\\n                chainId: _chainId\\n            });\\n        } else {\\n            Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_transaction);\\n\\n            return EIP155Transaction({\\n                nonce: Lib_RLPReader.readUint256(decoded[0]),\\n                gasPrice: Lib_RLPReader.readUint256(decoded[1]),\\n                gasLimit: Lib_RLPReader.readUint256(decoded[2]),\\n                to: Lib_RLPReader.readAddress(decoded[3]),\\n                value: Lib_RLPReader.readUint256(decoded[4]),\\n                data: Lib_RLPReader.readBytes(decoded[5]),\\n                chainId:  Lib_RLPReader.readUint256(decoded[6])\\n            });\\n        }\\n    }\\n\\n    function decompressEIP155Transaction(\\n        bytes memory _transaction\\n    )\\n        internal\\n        returns (\\n            EIP155Transaction memory _decompressed\\n        )\\n    {\\n        return EIP155Transaction({\\n            gasLimit: Lib_BytesUtils.toUint24(_transaction, 0),\\n            gasPrice: uint256(Lib_BytesUtils.toUint24(_transaction, 3)) * 1000000,\\n            nonce: Lib_BytesUtils.toUint24(_transaction, 6),\\n            to: Lib_BytesUtils.toAddress(_transaction, 9),\\n            data: Lib_BytesUtils.slice(_transaction, 29),\\n            chainId: Lib_SafeExecutionManagerWrapper.safeCHAINID(),\\n            value: 0\\n        });\\n    }\\n\\n    /**\\n     * Encodes an EOA transaction back into the original transaction.\\n     * @param _transaction EIP155transaction to encode.\\n     * @param _isEthSignedMessage Whether or not this was an eth signed message.\\n     * @return Encoded transaction.\\n     */\\n    function encodeEIP155Transaction(\\n        EIP155Transaction memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            return abi.encode(\\n                _transaction.nonce,\\n                _transaction.gasLimit,\\n                _transaction.gasPrice,\\n                _transaction.chainId,\\n                _transaction.to,\\n                _transaction.data\\n            );\\n        } else {\\n            bytes[] memory raw = new bytes[](9);\\n\\n            raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\\n            raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\\n            raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\\n            if (_transaction.to == address(0)) {\\n                raw[3] = Lib_RLPWriter.writeBytes('');\\n            } else {\\n                raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\\n            }\\n            raw[4] = Lib_RLPWriter.writeUint(0);\\n            raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId);\\n            raw[7] = Lib_RLPWriter.writeBytes(bytes(''));\\n            raw[8] = Lib_RLPWriter.writeBytes(bytes(''));\\n\\n            return Lib_RLPWriter.writeList(raw);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return _encoded Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return _hash Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * Converts an OVM account to an EVM account.\\n     * @param _in OVM account to convert.\\n     * @return _out Converted EVM account.\\n     */\\n    function toEVMAccount(\\n        Account memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory _out\\n        )\\n    {\\n        return EVMAccount({\\n            nonce: _in.nonce,\\n            balance: _in.balance,\\n            storageRoot: _in.storageRoot,\\n            codeHash: _in.codeHash\\n        });\\n    }\\n\\n    /**\\n     * @notice RLP-encodes an account state struct.\\n     * @param _account Account state struct.\\n     * @return _encoded RLP-encoded account state.\\n     */\\n    function encodeEVMAccount(\\n        EVMAccount memory _account\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](4);\\n\\n        // Unfortunately we can't create this array outright because\\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\\n        // index-by-index circumvents this issue.\\n        raw[0] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.nonce)\\n            )\\n        );\\n        raw[1] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.balance)\\n            )\\n        );\\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return _account Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory _account\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return _hash Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x19d78734777b4998f1544e235cf3934f20c5055cd76c2bd60bf0f6dacdd72b3a\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Contract Imports */\\nimport { Ownable } from \\\"./Lib_Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string _name,\\n        address _newAddress\\n    );\\n\\n    /*******************************************\\n     * Contract Variables: Internal Accounting *\\n     *******************************************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        public\\n        onlyOwner\\n    {\\n        emit AddressSet(_name, _address);\\n        addresses[_getNameHash(_name)] = _address;\\n    }\\n\\n    function getAddress(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0x3a490595cc21ff170e4027843093670ff845d5972481fbfb956b722ea564bb06\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\ncontract Lib_AddressResolver {\\n\\n    /*******************************************\\n     * Contract Variables: Contract References *\\n     *******************************************/\\n\\n    Lib_AddressManager internal libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) public {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address _contract\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0xc44f1c6e022e57ba6d62f2eaccc9bca2fec54b38d52b6e7288f71ddc133ef61d\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Ownable\\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\nabstract contract Ownable {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    address public owner;\\n\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor() internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            owner == msg.sender,\\n            \\\"Ownable: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function renounceOwnership()\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    function transferOwnership(address _newOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(\\n            _newOwner != address(0),\\n            \\\"Ownable: new owner cannot be the zero address\\\"\\n        );\\n\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0xeaed44565a7fd2c957b5a30d999934b93d558d4fa8011aa48afafeda76b8bf6e\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    \\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n    \\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n    \\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n            \\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xf0c0dbbe5e77adb1b603d6d4af319d15cea8c6d66fd5dca8115d80917617bf77\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = Lib_BytesUtils.concat(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return _out The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return Lib_BytesUtils.concat(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return _out The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return _out The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return _out The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return _encoded RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return _binary RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _binary\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return _flattened The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _flattened\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x854dfe1ed365e5840ad9b9d1330f5b196d4b1b9890a1187f3d32d785acd742bf\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _out\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _out\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address _out\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _out\\n        )\\n    {\\n        return bytes32(uint256(_in));\\n    }\\n\\n    function removeLeadingZeros(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory out;\\n\\n        assembly {\\n            // Figure out how many leading zero bytes to remove.\\n            let shift := 0\\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\\n                shift := add(shift, 1)\\n            }\\n\\n            // Reserve some space for our output and fix the free memory pointer.\\n            out := mload(0x40)\\n            mstore(0x40, add(out, 0x40))\\n\\n            // Shift the value and store it into the output bytes.\\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\\n\\n            // Store the new size (with leading zero bytes removed) in the output byte size.\\n            mstore(out, sub(32, shift))\\n        }\\n\\n        return out;\\n    }\\n}\\n\",\"keccak256\":\"0x438bb0b8f4c188b29eb4c4b1b9473841d957f779eff36dbb0115b9f81bd4e815\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (_bytes.length - _start == 0) {\\n            return bytes('');\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0x2d3a590134be0a2ee41673dfe97f2ab9a00224f4f1603f9b1bb068c4fcee6014\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_ECDSAUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_ECDSAUtils\\n */\\nlibrary Lib_ECDSAUtils {\\n\\n    /**************************************\\n     * Internal Functions: ECDSA Recovery *\\n     **************************************/\\n\\n    /**\\n     * Recovers a signed address given a message and signature.\\n     * @param _message Message that was originally signed.\\n     * @param _isEthSignedMessage Whether or not the user used the `Ethereum Signed Message` prefix.\\n     * @param _v Signature `v` parameter.\\n     * @param _r Signature `r` parameter.\\n     * @param _s Signature `s` parameter.\\n     * @return _sender Signer address.\\n     */\\n    function recover(\\n        bytes memory _message,\\n        bool _isEthSignedMessage,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        internal\\n        pure\\n        returns (\\n            address _sender\\n        )\\n    {\\n        bytes32 messageHash = getMessageHash(_message, _isEthSignedMessage);\\n\\n        return ecrecover(\\n            messageHash,\\n            _v + 27,\\n            _r,\\n            _s\\n        );\\n    }\\n\\n    function getMessageHash(\\n        bytes memory _message,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (bytes32) {\\n        if (_isEthSignedMessage) {\\n            return getEthSignedMessageHash(_message);\\n        }\\n        return getNativeMessageHash(_message);\\n    }\\n\\n\\n    /*************************************\\n     * Private Functions: ECDSA Recovery *\\n     *************************************/\\n\\n    /**\\n     * Gets the native message hash (simple keccak256) for a message.\\n     * @param _message Message to hash.\\n     * @return _messageHash Native message hash.\\n     */\\n    function getNativeMessageHash(\\n        bytes memory _message\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes32 _messageHash\\n        )\\n    {\\n        return keccak256(_message);\\n    }\\n\\n    /**\\n     * Gets the hash of a message with the `Ethereum Signed Message` prefix.\\n     * @param _message Message to hash.\\n     * @return _messageHash Prefixed message hash.\\n     */\\n    function getEthSignedMessageHash(\\n        bytes memory _message\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes32 _messageHash\\n        )\\n    {\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 messageHash = keccak256(_message);\\n        return keccak256(abi.encodePacked(prefix, messageHash));\\n    }\\n}\",\"keccak256\":\"0xda865d8cc014940a4755e329db9c6272a31bd9a340000a4ecc005d46299a585c\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_EthUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"./Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_EthUtils\\n */\\nlibrary Lib_EthUtils {\\n\\n    /***********************************\\n     * Internal Functions: Code Access *\\n     ***********************************/\\n\\n    /**\\n     * Gets the code for a given address.\\n     * @param _address Address to get code for.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return _code Code read from the contract.\\n     */\\n    function getCode(\\n        address _address,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory _code\\n        )\\n    {\\n        assembly {\\n            _code := mload(0x40)\\n            mstore(0x40, add(_code, add(_length, 0x20)))\\n            mstore(_code, _length)\\n            extcodecopy(_address, add(_code, 0x20), _offset, _length)\\n        }\\n\\n        return _code;\\n    }\\n\\n    /**\\n     * Gets the full code for a given address.\\n     * @param _address Address to get code for.\\n     * @return _code Full code of the contract.\\n     */\\n    function getCode(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes memory _code\\n        )\\n    {\\n        return getCode(\\n            _address,\\n            0,\\n            getCodeSize(_address)\\n        );\\n    }\\n\\n    /**\\n     * Gets the size of a contract's code in bytes.\\n     * @param _address Address to get code size for.\\n     * @return _codeSize Size of the contract's code in bytes.\\n     */\\n    function getCodeSize(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 _codeSize\\n        )\\n    {\\n        assembly {\\n            _codeSize := extcodesize(_address)\\n        }\\n\\n        return _codeSize;\\n    }\\n\\n    /**\\n     * Gets the hash of a contract's code.\\n     * @param _address Address to get a code hash for.\\n     * @return _codeHash Hash of the contract's code.\\n     */\\n    function getCodeHash(\\n        address _address\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32 _codeHash\\n        )\\n    {\\n        assembly {\\n            _codeHash := extcodehash(_address)\\n        }\\n\\n        return _codeHash;\\n    }\\n\\n\\n    /*****************************************\\n     * Internal Functions: Contract Creation *\\n     *****************************************/\\n\\n    /**\\n     * Creates a contract with some given initialization code.\\n     * @param _code Contract initialization code.\\n     * @return _created Address of the created contract.\\n     */\\n    function createContract(\\n        bytes memory _code\\n    )\\n        internal\\n        returns (\\n            address _created\\n        )\\n    {\\n        assembly {\\n            _created := create(\\n                0,\\n                add(_code, 0x20),\\n                mload(_code)\\n            )\\n        }\\n\\n        return _created;\\n    }\\n\\n    /**\\n     * Computes the address that would be generated by CREATE.\\n     * @param _creator Address creating the contract.\\n     * @param _nonce Creator's nonce.\\n     * @return _address Address to be generated by CREATE.\\n     */\\n    function getAddressForCREATE(\\n        address _creator,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (\\n            address _address\\n        )\\n    {\\n        bytes[] memory encoded = new bytes[](2);\\n        encoded[0] = Lib_RLPWriter.writeAddress(_creator);\\n        encoded[1] = Lib_RLPWriter.writeUint(_nonce);\\n\\n        bytes memory encodedList = Lib_RLPWriter.writeList(encoded);\\n        return Lib_Bytes32Utils.toAddress(keccak256(encodedList));\\n    }\\n\\n    /**\\n     * Computes the address that would be generated by CREATE2.\\n     * @param _creator Address creating the contract.\\n     * @param _bytecode Bytecode of the contract to be created.\\n     * @param _salt 32 byte salt value mixed into the hash.\\n     * @return _address Address to be generated by CREATE2.\\n     */\\n    function getAddressForCREATE2(\\n        address _creator,\\n        bytes memory _bytecode,\\n        bytes32 _salt\\n    )\\n        internal\\n        pure\\n        returns (address _address)\\n    {\\n        bytes32 hashedData = keccak256(abi.encodePacked(\\n            byte(0xff),\\n            _creator,\\n            _salt,\\n            keccak256(_bytecode)\\n        ));\\n\\n        return Lib_Bytes32Utils.toAddress(hashedData);\\n    }\\n}\\n\",\"keccak256\":\"0x5fdf009da11f90cb5e99e5cd160d07bb744a5a2055774a646bdf277ad6910595\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_SafeExecutionManagerWrapper\\n * @dev The Safe Execution Manager Wrapper provides functions which facilitate writing OVM safe \\n * code using the standard solidity compiler, by routing all its operations through the Execution \\n * Manager.\\n * \\n * Compiler used: solc\\n * Runtime target: OVM\\n */\\nlibrary Lib_SafeExecutionManagerWrapper {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Performs a safe ovmCALL.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeCALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Performs a safe ovmDELEGATECALL.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeDELEGATECALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmDELEGATECALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCREATE call.\\n     * @param _gasLimit Gas limit for the creation.\\n     * @param _bytecode Code for the new contract.\\n     * @return _contract Address of the created contract.\\n     */\\n    function safeCREATE(\\n        uint256 _gasLimit,\\n        bytes memory _bytecode\\n    )\\n        internal\\n        returns (\\n            address _contract\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            _gasLimit,\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATE(bytes)\\\",\\n                _bytecode\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmEXTCODESIZE call.\\n     * @param _contract Address of the contract to query the size of.\\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\\n     */\\n    function safeEXTCODESIZE(\\n        address _contract\\n    )\\n        internal\\n        returns (\\n            uint256 _EXTCODESIZE\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmEXTCODESIZE(address)\\\",\\n                _contract\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCHAINID call.\\n     * @return _CHAINID Result of calling ovmCHAINID.\\n     */\\n    function safeCHAINID()\\n        internal\\n        returns (\\n            uint256 _CHAINID\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCHAINID()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCALLER call.\\n     * @return _CALLER Result of calling ovmCALLER.\\n     */\\n    function safeCALLER()\\n        internal\\n        returns (\\n            address _CALLER\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALLER()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmADDRESS call.\\n     * @return _ADDRESS Result of calling ovmADDRESS.\\n     */\\n    function safeADDRESS()\\n        internal\\n        returns (\\n            address _ADDRESS\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmADDRESS()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmGETNONCE call.\\n     * @return _nonce Result of calling ovmGETNONCE.\\n     */\\n    function safeGETNONCE()\\n        internal\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmGETNONCE()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmSETNONCE call.\\n     * @param _nonce New account nonce.\\n     */\\n    function safeSETNONCE(\\n        uint256 _nonce\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSETNONCE(uint256)\\\",\\n                _nonce\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe ovmCREATEEOA call.\\n     * @param _messageHash Message hash which was signed by EOA\\n     * @param _v v value of signature (0 or 1)\\n     * @param _r r value of signature\\n     * @param _s s value of signature\\n     */\\n    function safeCREATEEOA(\\n        bytes32 _messageHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\\\",\\n                _messageHash,\\n                _v,\\n                _r,\\n                _s\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe REVERT.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREVERT(\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmREVERT(bytes)\\\",\\n                bytes(_reason)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe \\\"require\\\".\\n     * @param _condition Boolean condition that must be true or will revert.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREQUIRE(\\n        bool _condition,\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        if (!_condition) {\\n            safeREVERT(\\n                _reason\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Performs a safe ovmSLOAD call.\\n     */\\n    function safeSLOAD(\\n        bytes32 _key\\n    )\\n        internal\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSLOAD(bytes32)\\\",\\n                _key\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bytes32));\\n    }\\n\\n    /**\\n     * Performs a safe ovmSSTORE call.\\n     */\\n    function safeSSTORE(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSSTORE(bytes32,bytes32)\\\",\\n                _key,\\n                _value\\n            )\\n        );\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Performs an ovm interaction and the necessary safety checks.\\n     * @param _gasLimit Gas limit for the interaction.\\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\\n     */\\n    function _safeExecutionManagerInteraction(\\n        uint256 _gasLimit,\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        address ovmExecutionManager = msg.sender;\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\\n\\n        if (success == false) {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else if (returndata.length == 1) {\\n            assembly {\\n                return(0, 1)\\n            }\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _safeExecutionManagerInteraction(\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        return _safeExecutionManagerInteraction(\\n            gasleft(),\\n            _calldata\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xaf87c3829bcb83f6385e9316f5b14f68f838c21946c480625bce6cf743440de2\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeMathWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Pulled from @openzeppelin/contracts/math/SafeMath.sol\\n// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"./Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title Lib_SafeMathWrapper\\n */\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\n\\nlibrary Lib_SafeMathWrapper {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal returns (uint256) {\\n        uint256 c = a + b;\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(c >= a, \\\"Lib_SafeMathWrapper: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\\n        return sub(a, b, \\\"Lib_SafeMathWrapper: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(c / a == b, \\\"Lib_SafeMathWrapper: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal returns (uint256) {\\n        return div(a, b, \\\"Lib_SafeMathWrapper: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal returns (uint256) {\\n        return mod(a, b, \\\"Lib_SafeMathWrapper: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal returns (uint256) {\\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\",\"keccak256\":\"0xc58aa064894677f65fc8205f79252d15e59a0f5e2794e5c2d069c7b2bc97a9e2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620039ae380380620039ae8339810160408190526200003491620001e9565b600080546001600160a01b0319166001600160a01b03851617905560408051808201909152601181527027ab26afa9b0b332ba3ca1b432b1b5b2b960791b60208201526200008290620000cb565b600180546001600160a01b0319166001600160a01b039290921691909117905581516003556020820151600455604082015160055560609091015160065551600755506200028e565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156200012d57818101518382015260200162000113565b50505050905090810190601f1680156200015b5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156200017957600080fd5b505afa1580156200018e573d6000803e3d6000fd5b505050506040513d6020811015620001a557600080fd5b505192915050565b600060208284031215620001bf578081fd5b604051602081016001600160401b0381118282101715620001dc57fe5b6040529151825250919050565b600080600083850360c0811215620001ff578384fd5b84516001600160a01b038116811462000216578485fd5b93506080601f19820112156200022a578283fd5b50604051608081016001600160401b03811182821017156200024857fe5b80604052506020850151815260408501516020820152606085015160408201526080850151606082015280925050620002858560a08601620001ad565b90509250925092565b613710806200029e6000396000f3fe60806040523480156200001157600080fd5b5060043610620001d25760003560e01c8063741a33eb1162000111578063996d79a511620000a55780639dc9dc93116200007b5780639dc9dc9314620003e4578063bdbf8c3614620003ee578063c1fb2ea214620003f8578063ffe73914146200040257620001d2565b8063996d79a514620003ac57806399ccd98b14620003b65780639be3ad6714620003cd57620001d2565b80638540661f11620000e75780638540661f146200034d57806385979f7614620003745780638bb42e15146200038b5780639058025614620003a257620001d2565b8063741a33eb14620002f9578063746c32f114620003105780638435035b146200033657620001d2565b806322bd64c01162000189578063461a4478116200015f578063461a447814620002b75780634d78009214620002ce5780635a98c36114620002e55780637350906414620002ef57620001d2565b806322bd64c0146200027257806324749d5c14620002895780632a2a7adb14620002a057620001d2565b806303daa95914620001d75780630da449d11462000206578063101185a4146200021f57806314aa2ff714620002385780631c4712a7146200025e57806320160f3a1462000268575b600080fd5b620001ee620001e8366004620027ac565b62000419565b604051620001fd919062002b83565b60405180910390f35b6200021d62000217366004620027ac565b62000463565b005b62000229620004a0565b604051620001fd919062002c74565b6200024f6200024936600462002843565b620004a9565b604051620001fd919062002b8c565b620001ee6200054a565b620001ee62000550565b6200021d62000283366004620027de565b62000556565b620001ee6200029a366004620026c2565b620005c1565b6200021d620002b136600462002843565b620005e0565b6200024f620002c83660046200296e565b620005ed565b6200021d620002df36600462002700565b620006cf565b620001ee620008b3565b6200024f620008b9565b6200021d6200030a36600462002800565b620008c8565b620003276200032136600462002753565b62000a52565b604051620001fd919062002c5f565b620001ee62000347366004620026c2565b62000a8b565b620003646200035e36600462002a76565b62000aa2565b604051620001fd92919062002c24565b620003646200038536600462002a76565b62000b1f565b620003646200039c36600462002a0d565b62000b70565b620001ee62000c4e565b6200024f62000c54565b6200024f620003c736600462002881565b62000c63565b6200021d620003de366004620029b8565b62000cfd565b6200024f62000e5b565b620001ee62000e6a565b620001ee62000e70565b620003646200041336600462002a76565b62000e8b565b6000619c4060005a905060006200042f62000c54565b90506200043d818662000f04565b93505060005a82039050808310156200045b57601080548483030190555b505050919050565b600f5460ff600160a01b90910416151560011415620004885762000488600762000fa3565b6200049d6200049662000c54565b8262000fbe565b50565b60085460ff1690565b600f5460009060ff600160a01b90910416151560011415620004d157620004d1600762000fa3565b619c4060005a90506000620004e562000c54565b9050620004f28162001035565b60006200050a826200050484620010c4565b62001157565b9050620005188187620011f3565b9450505060005a82039050808310156200053a5760108054840190556200045b565b6010805482019055505050919050565b60045490565b600b5490565b600f5460ff600160a01b909104161515600114156200057b576200057b600762000fa3565b61ea6060005a905060006200058f62000c54565b90506200059e818686620012c1565b5060005a8203905080831015620005ba57601080548483030190555b5050505050565b6000620005d8620005d28362001352565b620013e5565b90505b919050565b6200049d600282620013e9565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156200064f57818101518382015260200162000635565b50505050905090810190601f1680156200067d5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156200069b57600080fd5b505afa158015620006b0573d6000803e3d6000fd5b505050506040513d6020811015620006c757600080fd5b505192915050565b333014620006dd57620008af565b620006e88262001430565b620006f957620006f9600662000fa3565b6001546040516352275acd60e11b81526001600160a01b039091169063a44eb59a906200072b90849060040162002c5f565b60206040518083038186803b1580156200074457600080fd5b505afa15801562000759573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200077f91906200278a565b620007905762000790600562000fa3565b6200079b82620014c3565b6000620007a88262001530565b90506001600160a01b038116620007c557620007c5600862000fa3565b600060125460ff166009811115620007d957fe5b14620007f057601254620007f09060ff1662000fa3565b6000620007fd8262001541565b6001546040516352275acd60e11b81529192506001600160a01b03169063a44eb59a906200083090849060040162002c5f565b60206040518083038186803b1580156200084957600080fd5b505afa1580156200085e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200088491906200278a565b620008955762000895600562000fa3565b620008ac8483620008a685620013e5565b6200155b565b50505b5050565b600a5490565b600e546001600160a01b031690565b600f5460ff600160a01b90910416151560011415620008ed57620008ed600762000fa3565b600060018585601b0185856040516000815260200160405260405162000917949392919062002c41565b6020604051602081039080840390855afa1580156200093a573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166200097a576200097a604051806060016040528060388152602001620036a360389139620005e0565b620009858162001430565b620009915750620008ac565b6200099c81620014c3565b600f80546001600160a01b038381166001600160a01b03198316179092556040519116906000906003602160991b0190620009d7906200258d565b620009e3919062002b8c565b604051809103906000f08015801562000a00573d6000803e3d6000fd5b50600f80546001600160a01b0319166001600160a01b038516179055905062000a3c838262000a2f8162001541565b805190602001206200155b565b62000a4983600062000fbe565b50505050505050565b606060008260011462000a66578262000a69565b60025b905062000a8262000a7a8662001352565b85836200159c565b95945050505050565b6000620005d862000a9c8362001352565b620015be565b600060606201388060005a60408051606081018252600f546001600160a01b0390811682528916602082015260019181019190915290915062000ae881898989620015c2565b945094505060005a820390508083101562000b0b57601080548401905562000b14565b60108054820190555b505050935093915050565b60006060620186a060005a60408051606081018252600f5460ff600160a01b8204161515928201929092526001600160a01b039182168152908816602082015290915062000ae881898989620015c2565b60006060331562000b8057600080fd5b600280546001600160a01b0319166001600160a01b03851617905562000ba68562001659565b6000196011556080850151600f80546001600160a01b039283166001600160a01b03199182168117909255600e8054938816939091169290921790915560a086015160c087015160405162000bfc919062002b65565b60006040518083038160008787f1925050503d806000811462000c3c576040519150601f19603f3d011682016040523d82523d6000602084013e62000c41565b606091505b5091509150935093915050565b60075490565b600f546001600160a01b031690565b600f5460009060ff600160a01b9091041615156001141562000c8b5762000c8b600762000fa3565b619c4060005a9050600062000c9f62000c54565b905062000cac8162001035565b600062000cbb828888620016ce565b905062000cc98188620011f3565b9450505060005a820390508083101562000ceb57601080548401905562000cf4565b60108054820190555b50505092915050565b600a541562000d295760405162461bcd60e51b815260040162000d209062002d65565b60405180910390fd5b600280546001600160a01b0319166001600160a01b038381169190911791829055604051630d15d41560e41b815291169063d15d41509062000d7090339060040162002b8c565b60206040518083038186803b15801562000d8957600080fd5b505afa15801562000d9e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000dc491906200278a565b62000de35760405162461bcd60e51b815260040162000d209062002cf9565b62000dee8262001659565b62000e028260a00151836040015162001718565b62000e0d57620008af565b60005a905062000e326003600001548460a001510384608001518560c0015162000b1f565b505060005a8203905062000e456200174c565b5050600280546001600160a01b03191690555050565b600d546001600160a01b031690565b60095490565b600062000e8662000e8062000c54565b620010c4565b905090565b60006060619c4060005a60408051606081018252600e546001600160a01b039081168252600f549081166020830152600160a01b900460ff16151591810191909152909150600062000ee0828a8a8a620015c2565b95509550505060005a820390508083101562000b0b57601080548401905562000b14565b600062000f128383620017af565b600254604051631aaf392f60e01b81526001600160a01b0390911690631aaf392f9062000f46908690869060040162002bc4565b60206040518083038186803b15801562000f5f57600080fd5b505afa15801562000f74573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000f9a9190620027c5565b90505b92915050565b6200049d8160405180602001604052806000815250620013e9565b62000fc982620018ff565b6002546040516374855dc360e11b81526001600160a01b039091169063e90abb869062000ffd908590859060040162002bc4565b600060405180830381600087803b1580156200101857600080fd5b505af11580156200102d573d6000803e3d6000fd5b505050505050565b600080620010885a6002602160991b018560405160240162001058919062002b8c565b60408051601f198184030181529190526020810180516001600160e01b031663b1540a0160e01b17905262000b1f565b91509150600081806020019051810190620010a491906200278a565b9050801580620010b2575082155b15620008ac57620008ac600962000fa3565b6000620010d18262001a25565b60025460405163d126199f60e01b81526001600160a01b039091169063d126199f906200110390859060040162002b8c565b60206040518083038186803b1580156200111c57600080fd5b505afa15801562001131573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d89190620027c5565b60408051600280825260608201909252600091829190816020015b606081526020019060019003908162001172579050509050620011958462001b7c565b81600081518110620011a357fe5b6020026020010181905250620011b98362001baa565b81600181518110620011c757fe5b60200260200101819052506000620011df8262001bc1565b905062000a82818051906020012062001bf2565b60006200121a6200120362000c54565b6200121162000e8062000c54565b60010162000fbe565b60408051606081018252600f5460ff600160a01b8204161515928201929092526001600160a01b039182168152908416602082015260006200129d825a3088886040516024016200126d92919062002bfe565b60408051601f198184030181529190526020810180516001600160e01b03166326bc004960e11b17905262001bf5565b506012805460ff19169055905080620012b857600062000a82565b50929392505050565b80620012ce848462000f04565b1415620012db576200134d565b620012e7838362001dc7565b600254604051635c17d62960e01b81526001600160a01b0390911690635c17d629906200131d9086908690869060040162002bdd565b600060405180830381600087803b1580156200133857600080fd5b505af115801562000a49573d6000803e3d6000fd5b505050565b60006200135f8262001a25565b600254604051637c8ee70360e01b81526001600160a01b0390911690637c8ee703906200139190859060040162002b8c565b60206040518083038186803b158015620013aa57600080fd5b505afa158015620013bf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d89190620026e1565b3f90565b333b15801562001418576012805484919060ff191660018360098111156200140d57fe5b021790555060016000f35b600062001426848462001ee8565b9050805160208201fd5b60006200143d8262001a25565b6002546040516307a1294560e01b81526001600160a01b03909116906307a12945906200146f90859060040162002b8c565b60206040518083038186803b1580156200148857600080fd5b505afa1580156200149d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d891906200278a565b620014ce8162001a25565b600254604051637e78a4d160e11b81526001600160a01b039091169063fcf149a2906200150090849060040162002b8c565b600060405180830381600087803b1580156200151b57600080fd5b505af1158015620005ba573d6000803e3d6000fd5b60008151602083016000f092915050565b6060620005d88260006200155585620015be565b6200159c565b6200156683620018ff565b6002546040516368510af960e11b81526001600160a01b039091169063d0a215f2906200131d9086908690869060040162002ba0565b60606040519050602082018101604052818152818360208301863c9392505050565b3b90565b6000606073ffffffffffffffffffffffffffffffffffff0000841673deaddeaddeaddeaddeaddeaddeaddeaddead000014156200161357505060408051602081019091526000815260019062001650565b60006064856001600160a01b0316106200163857620016328562001352565b6200163a565b845b90506200164a8787838762001bf5565b92509250505b94509492505050565b80516009556020810151600a5560a0810151600c5560408101516008805460ff1916600183818111156200168957fe5b02179055506060810151600d80546001600160a01b0319166001600160a01b03909216919091179055600554600b5560a0810151620016c89062001fb3565b60115550565b60008060ff60f81b85848680519060200120604051602001620016f5949392919062002b2c565b60405160208183030381529060405280519060200120905062000a828162001bf2565b6004546000908311156200172f5750600062000f9d565b600354831015620017435750600062000f9d565b50600192915050565b600d80546001600160a01b031990811690915560006009819055600a819055600b819055600c8190556008805460ff199081169091556010829055600e8054909316909255600f80546001600160a81b0319169055601155601280549091169055565b6175305a1015620017c657620017c6600162000fa3565b600254604051630ad2267960e01b81526001600160a01b0390911690630ad2267990620017fa908590859060040162002bc4565b60206040518083038186803b1580156200181357600080fd5b505afa15801562001828573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200184e91906200278a565b6200185f576200185f600462000fa3565b600254604051632bcdee1960e21b81526000916001600160a01b03169063af37b8649062001894908690869060040162002bc4565b602060405180830381600087803b158015620018af57600080fd5b505af1158015620018c4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620018ea91906200278a565b9050806200134d576200134d614e2062001fc8565b6200190a8162001a25565b60025460405163011b1f7960e41b81526000916001600160a01b0316906311b1f790906200193d90859060040162002b8c565b602060405180830381600087803b1580156200195857600080fd5b505af11580156200196d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200199391906200278a565b905080620008af57600260009054906101000a90046001600160a01b03166001600160a01b03166333f943056040518163ffffffff1660e01b8152600401600060405180830381600087803b158015620019ec57600080fd5b505af115801562001a01573d6000803e3d6000fd5b50505050620008af617530606462001a1d62000a9c8662001352565b020162001fc8565b6175305a101562001a3c5762001a3c600162000fa3565b60025460405163c8e40fbf60e01b81526001600160a01b039091169063c8e40fbf9062001a6e90849060040162002b8c565b60206040518083038186803b15801562001a8757600080fd5b505afa15801562001a9c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001ac291906200278a565b62001ad35762001ad3600462000fa3565b600254604051633ecdecc760e21b81526000916001600160a01b03169063fb37b31c9062001b0690859060040162002b8c565b602060405180830381600087803b15801562001b2157600080fd5b505af115801562001b36573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001b5c91906200278a565b905080620008af57620008af617530606462001a1d62000a9c8662001352565b6060620005d88260405160200162001b95919062002b0f565b60405160208183030381529060405262001feb565b6060620005d862001bbb836200203c565b62001feb565b6060600062001bd0836200214d565b905062001beb62001be4825160c06200225a565b82620023b7565b9392505050565b90565b6040805160608082018352600e546001600160a01b039081168352600f549081166020840152600160a01b900460ff161515928201929092526000919062001c3e818862002438565b601154600062001c4e8862001fb3565b905080601160000181905550600080886001600160a01b03168a8960405162001c78919062002b65565b60006040518083038160008787f1925050503d806000811462001cb8576040519150601f19603f3d011682016040523d82523d6000602084013e62001cbd565b606091505b509150915062001cce8b8662002438565b6011548262001db05760008060008062001ce886620024ef565b92965090945092509050600484600981111562001d0157fe5b141562001d135762001d138462000fa3565b600284600981111562001d2257fe5b148062001d3b5750600584600981111562001d3957fe5b145b8062001d535750600784600981111562001d5157fe5b145b8062001d6b5750600984600981111562001d6957fe5b145b1562001d775760108290555b600284600981111562001d8657fe5b141562001d965780955062001da9565b6040518060200160405280600081525095505b5090925050505b909203909203601155909890975095505050505050565b62001dd38282620017af565b60025460405163af3dc01160e01b81526000916001600160a01b03169063af3dc0119062001e08908690869060040162002bc4565b602060405180830381600087803b15801562001e2357600080fd5b505af115801562001e38573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001e5e91906200278a565b9050806200134d5762001e7183620018ff565b600260009054906101000a90046001600160a01b03166001600160a01b031663c3fd9b256040518163ffffffff1660e01b8152600401600060405180830381600087803b15801562001ec257600080fd5b505af115801562001ed7573d6000803e3d6000fd5b505050506200134d614e2062001fc8565b6060600183600981111562001ef957fe5b148062001f125750600883600981111562001f1057fe5b145b1562001f2e575060408051602081019091526000815262000f9d565b600483600981111562001f3d57fe5b141562001f7f5760408051602080820183526000808352925162001f68938793909283920162002c89565b604051602081830303815290604052905062000f9d565b60115460105460405162001f9c9286929091869060200162002cc9565b604051602081830303815290604052905092915050565b60005a821062001fc4575a620005d8565b5090565b60115481111562001fdf5762001fdf600362000fa3565b60118054919091039055565b606080825160011480156200201557506080836000815181106200200b57fe5b016020015160f81c105b1562002023575081620005d8565b62000f9a62002035845160806200225a565b84620023b7565b606060008260405160200162002053919062002b83565b604051602081830303815290604052905060005b6020811015620020a2578181815181106200207e57fe5b01602001516001600160f81b031916156200209957620020a2565b60010162002067565b6000816020036001600160401b0381118015620020be57600080fd5b506040519080825280601f01601f191660200182016040528015620020ea576020820181803683370190505b50905060005b8151811015620021445783516001840193859181106200210c57fe5b602001015160f81c60f81b8282815181106200212457fe5b60200101906001600160f81b031916908160001a905350600101620020f0565b50949350505050565b6060815160001415620021705750604080516000815260208101909152620005db565b6000805b8351811015620021a6578381815181106200218b57fe5b60200260200101515182019150808060010191505062002174565b6000826001600160401b0381118015620021bf57600080fd5b506040519080825280601f01601f191660200182016040528015620021eb576020820181803683370190505b50600092509050602081015b8551831015620021445760008684815181106200221057fe5b602002602001015190506000602082019050620022308382845162002547565b8785815181106200223d57fe5b6020026020010151518301925050508280600101935050620021f7565b6060806038841015620022b7576040805160018082528183019092529060208201818036833701905050905082840160f81b816000815181106200229a57fe5b60200101906001600160f81b031916908160001a90535062000f9a565b600060015b808681620022c657fe5b0415620022dd5760019091019061010002620022bc565b816001016001600160401b0381118015620022f757600080fd5b506040519080825280601f01601f19166020018201604052801562002323576020820181803683370190505b50925084820160370160f81b836000815181106200233d57fe5b60200101906001600160f81b031916908160001a905350600190505b818111620023ae576101008183036101000a87816200237457fe5b04816200237d57fe5b0660f81b8382815181106200238e57fe5b60200101906001600160f81b031916908160001a90535060010162002359565b50509392505050565b6060806040519050835180825260208201818101602087015b81831015620023ea578051835260209283019201620023d0565b50855184518101855292509050808201602086015b8183101562002419578051835260209283019201620023ff565b508651929092011591909101601f01601f191660405250905092915050565b805182516001600160a01b0390811691161462002471578051600e80546001600160a01b0319166001600160a01b039092169190911790555b80602001516001600160a01b031682602001516001600160a01b031614620024b8576020810151600f80546001600160a01b0319166001600160a01b039092169190911790555b806040015115158260400151151514620008af5760400151600f8054911515600160a01b0260ff60a01b1990921691909117905550565b600080600060608451600014156200252157505060408051602081019091526000808252600193509150819062002540565b84806020019051810190620025379190620028c7565b93509350935093505b9193509193565b8282825b602081106200256c578151835260209283019290910190601f19016200254b565b905182516020929092036101000a6000190180199091169116179052505050565b6108648062002e3f83390190565b6000620025b2620025ac8462002dd7565b62002db3565b9050828152838383011115620025c757600080fd5b828260208301376000602084830101529392505050565b8035620005db8162002e28565b600082601f830112620025fc578081fd5b62000f9a838335602085016200259b565b803560028110620005db57600080fd5b600060e082840312156200262f578081fd5b6200263b60e062002db3565b9050813581526020820135602082015262002659604083016200260d565b60408201526200266c60608301620025de565b60608201526200267f60808301620025de565b608082015260a082013560a082015260c08201356001600160401b03811115620026a857600080fd5b620026b684828501620025eb565b60c08301525092915050565b600060208284031215620026d4578081fd5b813562000f9a8162002e28565b600060208284031215620026f3578081fd5b815162000f9a8162002e28565b6000806040838503121562002713578081fd5b8235620027208162002e28565b915060208301356001600160401b038111156200273b578182fd5b6200274985828601620025eb565b9150509250929050565b60008060006060848603121562002768578081fd5b8335620027758162002e28565b95602085013595506040909401359392505050565b6000602082840312156200279c578081fd5b8151801515811462000f9a578182fd5b600060208284031215620027be578081fd5b5035919050565b600060208284031215620027d7578081fd5b5051919050565b60008060408385031215620027f1578182fd5b50508035926020909101359150565b6000806000806080858703121562002816578182fd5b84359350602085013560ff811681146200282e578283fd5b93969395505050506040820135916060013590565b60006020828403121562002855578081fd5b81356001600160401b038111156200286b578182fd5b6200287984828501620025eb565b949350505050565b6000806040838503121562002894578182fd5b82356001600160401b03811115620028aa578283fd5b620028b885828601620025eb565b95602094909401359450505050565b60008060008060808587031215620028dd578182fd5b8451600a8110620028ec578283fd5b80945050602085015192506040850151915060608501516001600160401b0381111562002917578182fd5b8501601f8101871362002928578182fd5b805162002939620025ac8262002dd7565b8181528860208385010111156200294e578384fd5b6200296182602083016020860162002df9565b9598949750929550505050565b60006020828403121562002980578081fd5b81356001600160401b0381111562002996578182fd5b8201601f81018413620029a7578182fd5b62002879848235602084016200259b565b60008060408385031215620029cb578182fd5b82356001600160401b03811115620029e1578283fd5b620029ef858286016200261d565b925050602083013562002a028162002e28565b809150509250929050565b60008060006060848603121562002a22578081fd5b83356001600160401b0381111562002a38578182fd5b62002a46868287016200261d565b935050602084013562002a598162002e28565b9150604084013562002a6b8162002e28565b809150509250925092565b60008060006060848603121562002a8b578081fd5b83359250602084013562002a9f8162002e28565b915060408401356001600160401b0381111562002aba578182fd5b62002ac886828701620025eb565b9150509250925092565b6000815180845262002aec81602086016020860162002df9565b601f01601f19169290920160200192915050565b600a811062002b0b57fe5b9052565b60609190911b6bffffffffffffffffffffffff1916815260140190565b6001600160f81b031994909416845260609290921b6bffffffffffffffffffffffff191660018401526015830152603582015260550190565b6000825162002b7981846020870162002df9565b9190910192915050565b90815260200190565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b6001600160a01b039390931683526020830191909152604082015260600190565b6001600160a01b0383168152604060208201819052600090620028799083018462002ad2565b600083151582526040602083015262002879604083018462002ad2565b93845260ff9290921660208401526040830152606082015260800190565b60006020825262000f9a602083018462002ad2565b602081016002831062002c8357fe5b91905290565b600062002c97828762002b00565b60ff8516602083015260ff841660408301526080606083015262002cbf608083018462002ad2565b9695505050505050565b600062002cd7828762002b00565b8460208301528360408301526080606083015262002cbf608083018462002ad2565b60208082526046908201527f4f6e6c792061757468656e746963617465642061646472657373657320696e2060408201527f6f766d53746174654d616e616765722063616e2063616c6c20746869732066756060820152653731ba34b7b760d11b608082015260a00190565b6020808252602e908201527f4f6e6c792062652063616c6c61626c6520617420746865207374617274206f6660408201526d1030903a3930b739b0b1ba34b7b760911b606082015260800190565b6040518181016001600160401b038111828210171562002dcf57fe5b604052919050565b60006001600160401b0382111562002deb57fe5b50601f01601f191660200190565b60005b8381101562002e1657818101518382015260200162002dfc565b83811115620008ac5750506000910152565b6001600160a01b03811681146200049d57600080fdfe608060405234801561001057600080fd5b506040516108643803806108648339818101604052602081101561003357600080fd5b505161003e81610044565b506101c7565b6100877fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead60001b826001600160a01b031660001b61008a60201b6103ba1760201c565b50565b604080516024810184905260448082018490528251808303909101815260649091019091526020810180516001600160e01b03908116628af59360e61b179091526100d691906100db16565b505050565b60606100e75a836100ed565b92915050565b60606000339050600080826001600160a01b031686866040518082805190602001908083835b602083106101325780518252601f199092019160209182019101610113565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038160008787f1925050503d8060008114610195576040519150601f19603f3d011682016040523d82523d6000602084013e61019a565b606091505b509092509050816101ad57805160208201fd5b8051600114156101bd5760016000f35b92506100e7915050565b61068e806101d66000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80630900f010146100a1578063aaf10f42146100c9575b6000806100825a6100456100ed565b6000368080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061011d92505050565b91509150811561009457805160208201f35b61009d816102c0565b5050005b6100c7600480360360208110156100b757600080fd5b50356001600160a01b031661036a565b005b6100d16100ed565b604080516001600160a01b039092168252519081900360200190f35b60006101187fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead610406565b905090565b6000606060006101e586868660405160240180848152602001836001600160a01b0316815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561017e578181015183820152602001610166565b50505050905090810190601f1680156101ab5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b03166001620631bb60e21b0319179052945061046c9350505050565b90508080602001905160408110156101fc57600080fd5b81516020830180516040519294929383019291908464010000000082111561022357600080fd5b90830190602082018581111561023857600080fd5b825164010000000081118282018810171561025257600080fd5b82525081516020918201929091019080838360005b8381101561027f578181015183820152602001610267565b50505050905090810190601f1680156102ac5780820380516001836020036101000a031916815260200191505b506040525050509250925050935093915050565b610366816040516024018080602001828103825283818151815260200191508051906020019080838360005b838110156103045781810151838201526020016102ec565b50505050905090810190601f1680156103315780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b0316632a2a7adb60e01b179052925061046c915050565b5050565b6103ae61037561047e565b6001600160a01b03166103866104d4565b6001600160a01b0316146040518060600160405280603281526020016106276032913961050b565b6103b781610519565b50565b604080516024810184905260448082018490528251808303909101815260649091019091526020810180516001600160e01b0316628af59360e61b1790526104019061046c565b505050565b6040805160248082018490528251808303909101815260449091019091526020810180516001600160e01b03166303daa95960e01b179052600090819061044c9061046c565b905080806020019051602081101561046357600080fd5b50519392505050565b60606104785a8361054c565b92915050565b6040805160048152602481019091526020810180516001600160e01b0316631cd4241960e21b17905260009081906104b59061046c565b90508080602001905160208110156104cc57600080fd5b505191505090565b6040805160048152602481019091526020810180516001600160e01b031663996d79a560e01b17905260009081906104b59061046c565b8161036657610366816102c0565b6103b77fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead6001600160a01b0383166103ba565b60606000339050600080826001600160a01b031686866040518082805190602001908083835b602083106105915780518252601f199092019160209182019101610572565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038160008787f1925050503d80600081146105f4576040519150601f19603f3d011682016040523d82523d6000602084013e6105f9565b606091505b5090925090508161060c57805160208201fd5b80516001141561061c5760016000f35b925061047891505056fe454f41732063616e206f6e6c792075706772616465207468656972206f776e20454f4120696d706c656d656e746174696f6ea26469706673582212207f82637ab24ef9653a9774102bad776ee1ee930f0e1d73dfcad1f8fd1b18609a64736f6c634300070600335369676e61747572652070726f766964656420666f7220454f4120636f6e7472616374206372656174696f6e20697320696e76616c69642ea2646970667358221220f054814893c33a58bbcbd4f73988d982d06877b6e63ed1b5a478541f1e64b5b164736f6c63430007060033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620001d25760003560e01c8063741a33eb1162000111578063996d79a511620000a55780639dc9dc93116200007b5780639dc9dc9314620003e4578063bdbf8c3614620003ee578063c1fb2ea214620003f8578063ffe73914146200040257620001d2565b8063996d79a514620003ac57806399ccd98b14620003b65780639be3ad6714620003cd57620001d2565b80638540661f11620000e75780638540661f146200034d57806385979f7614620003745780638bb42e15146200038b5780639058025614620003a257620001d2565b8063741a33eb14620002f9578063746c32f114620003105780638435035b146200033657620001d2565b806322bd64c01162000189578063461a4478116200015f578063461a447814620002b75780634d78009214620002ce5780635a98c36114620002e55780637350906414620002ef57620001d2565b806322bd64c0146200027257806324749d5c14620002895780632a2a7adb14620002a057620001d2565b806303daa95914620001d75780630da449d11462000206578063101185a4146200021f57806314aa2ff714620002385780631c4712a7146200025e57806320160f3a1462000268575b600080fd5b620001ee620001e8366004620027ac565b62000419565b604051620001fd919062002b83565b60405180910390f35b6200021d62000217366004620027ac565b62000463565b005b62000229620004a0565b604051620001fd919062002c74565b6200024f6200024936600462002843565b620004a9565b604051620001fd919062002b8c565b620001ee6200054a565b620001ee62000550565b6200021d62000283366004620027de565b62000556565b620001ee6200029a366004620026c2565b620005c1565b6200021d620002b136600462002843565b620005e0565b6200024f620002c83660046200296e565b620005ed565b6200021d620002df36600462002700565b620006cf565b620001ee620008b3565b6200024f620008b9565b6200021d6200030a36600462002800565b620008c8565b620003276200032136600462002753565b62000a52565b604051620001fd919062002c5f565b620001ee62000347366004620026c2565b62000a8b565b620003646200035e36600462002a76565b62000aa2565b604051620001fd92919062002c24565b620003646200038536600462002a76565b62000b1f565b620003646200039c36600462002a0d565b62000b70565b620001ee62000c4e565b6200024f62000c54565b6200024f620003c736600462002881565b62000c63565b6200021d620003de366004620029b8565b62000cfd565b6200024f62000e5b565b620001ee62000e6a565b620001ee62000e70565b620003646200041336600462002a76565b62000e8b565b6000619c4060005a905060006200042f62000c54565b90506200043d818662000f04565b93505060005a82039050808310156200045b57601080548483030190555b505050919050565b600f5460ff600160a01b90910416151560011415620004885762000488600762000fa3565b6200049d6200049662000c54565b8262000fbe565b50565b60085460ff1690565b600f5460009060ff600160a01b90910416151560011415620004d157620004d1600762000fa3565b619c4060005a90506000620004e562000c54565b9050620004f28162001035565b60006200050a826200050484620010c4565b62001157565b9050620005188187620011f3565b9450505060005a82039050808310156200053a5760108054840190556200045b565b6010805482019055505050919050565b60045490565b600b5490565b600f5460ff600160a01b909104161515600114156200057b576200057b600762000fa3565b61ea6060005a905060006200058f62000c54565b90506200059e818686620012c1565b5060005a8203905080831015620005ba57601080548483030190555b5050505050565b6000620005d8620005d28362001352565b620013e5565b90505b919050565b6200049d600282620013e9565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156200064f57818101518382015260200162000635565b50505050905090810190601f1680156200067d5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156200069b57600080fd5b505afa158015620006b0573d6000803e3d6000fd5b505050506040513d6020811015620006c757600080fd5b505192915050565b333014620006dd57620008af565b620006e88262001430565b620006f957620006f9600662000fa3565b6001546040516352275acd60e11b81526001600160a01b039091169063a44eb59a906200072b90849060040162002c5f565b60206040518083038186803b1580156200074457600080fd5b505afa15801562000759573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200077f91906200278a565b620007905762000790600562000fa3565b6200079b82620014c3565b6000620007a88262001530565b90506001600160a01b038116620007c557620007c5600862000fa3565b600060125460ff166009811115620007d957fe5b14620007f057601254620007f09060ff1662000fa3565b6000620007fd8262001541565b6001546040516352275acd60e11b81529192506001600160a01b03169063a44eb59a906200083090849060040162002c5f565b60206040518083038186803b1580156200084957600080fd5b505afa1580156200085e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200088491906200278a565b620008955762000895600562000fa3565b620008ac8483620008a685620013e5565b6200155b565b50505b5050565b600a5490565b600e546001600160a01b031690565b600f5460ff600160a01b90910416151560011415620008ed57620008ed600762000fa3565b600060018585601b0185856040516000815260200160405260405162000917949392919062002c41565b6020604051602081039080840390855afa1580156200093a573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166200097a576200097a604051806060016040528060388152602001620036a360389139620005e0565b620009858162001430565b620009915750620008ac565b6200099c81620014c3565b600f80546001600160a01b038381166001600160a01b03198316179092556040519116906000906003602160991b0190620009d7906200258d565b620009e3919062002b8c565b604051809103906000f08015801562000a00573d6000803e3d6000fd5b50600f80546001600160a01b0319166001600160a01b038516179055905062000a3c838262000a2f8162001541565b805190602001206200155b565b62000a4983600062000fbe565b50505050505050565b606060008260011462000a66578262000a69565b60025b905062000a8262000a7a8662001352565b85836200159c565b95945050505050565b6000620005d862000a9c8362001352565b620015be565b600060606201388060005a60408051606081018252600f546001600160a01b0390811682528916602082015260019181019190915290915062000ae881898989620015c2565b945094505060005a820390508083101562000b0b57601080548401905562000b14565b60108054820190555b505050935093915050565b60006060620186a060005a60408051606081018252600f5460ff600160a01b8204161515928201929092526001600160a01b039182168152908816602082015290915062000ae881898989620015c2565b60006060331562000b8057600080fd5b600280546001600160a01b0319166001600160a01b03851617905562000ba68562001659565b6000196011556080850151600f80546001600160a01b039283166001600160a01b03199182168117909255600e8054938816939091169290921790915560a086015160c087015160405162000bfc919062002b65565b60006040518083038160008787f1925050503d806000811462000c3c576040519150601f19603f3d011682016040523d82523d6000602084013e62000c41565b606091505b5091509150935093915050565b60075490565b600f546001600160a01b031690565b600f5460009060ff600160a01b9091041615156001141562000c8b5762000c8b600762000fa3565b619c4060005a9050600062000c9f62000c54565b905062000cac8162001035565b600062000cbb828888620016ce565b905062000cc98188620011f3565b9450505060005a820390508083101562000ceb57601080548401905562000cf4565b60108054820190555b50505092915050565b600a541562000d295760405162461bcd60e51b815260040162000d209062002d65565b60405180910390fd5b600280546001600160a01b0319166001600160a01b038381169190911791829055604051630d15d41560e41b815291169063d15d41509062000d7090339060040162002b8c565b60206040518083038186803b15801562000d8957600080fd5b505afa15801562000d9e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000dc491906200278a565b62000de35760405162461bcd60e51b815260040162000d209062002cf9565b62000dee8262001659565b62000e028260a00151836040015162001718565b62000e0d57620008af565b60005a905062000e326003600001548460a001510384608001518560c0015162000b1f565b505060005a8203905062000e456200174c565b5050600280546001600160a01b03191690555050565b600d546001600160a01b031690565b60095490565b600062000e8662000e8062000c54565b620010c4565b905090565b60006060619c4060005a60408051606081018252600e546001600160a01b039081168252600f549081166020830152600160a01b900460ff16151591810191909152909150600062000ee0828a8a8a620015c2565b95509550505060005a820390508083101562000b0b57601080548401905562000b14565b600062000f128383620017af565b600254604051631aaf392f60e01b81526001600160a01b0390911690631aaf392f9062000f46908690869060040162002bc4565b60206040518083038186803b15801562000f5f57600080fd5b505afa15801562000f74573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000f9a9190620027c5565b90505b92915050565b6200049d8160405180602001604052806000815250620013e9565b62000fc982620018ff565b6002546040516374855dc360e11b81526001600160a01b039091169063e90abb869062000ffd908590859060040162002bc4565b600060405180830381600087803b1580156200101857600080fd5b505af11580156200102d573d6000803e3d6000fd5b505050505050565b600080620010885a6002602160991b018560405160240162001058919062002b8c565b60408051601f198184030181529190526020810180516001600160e01b031663b1540a0160e01b17905262000b1f565b91509150600081806020019051810190620010a491906200278a565b9050801580620010b2575082155b15620008ac57620008ac600962000fa3565b6000620010d18262001a25565b60025460405163d126199f60e01b81526001600160a01b039091169063d126199f906200110390859060040162002b8c565b60206040518083038186803b1580156200111c57600080fd5b505afa15801562001131573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d89190620027c5565b60408051600280825260608201909252600091829190816020015b606081526020019060019003908162001172579050509050620011958462001b7c565b81600081518110620011a357fe5b6020026020010181905250620011b98362001baa565b81600181518110620011c757fe5b60200260200101819052506000620011df8262001bc1565b905062000a82818051906020012062001bf2565b60006200121a6200120362000c54565b6200121162000e8062000c54565b60010162000fbe565b60408051606081018252600f5460ff600160a01b8204161515928201929092526001600160a01b039182168152908416602082015260006200129d825a3088886040516024016200126d92919062002bfe565b60408051601f198184030181529190526020810180516001600160e01b03166326bc004960e11b17905262001bf5565b506012805460ff19169055905080620012b857600062000a82565b50929392505050565b80620012ce848462000f04565b1415620012db576200134d565b620012e7838362001dc7565b600254604051635c17d62960e01b81526001600160a01b0390911690635c17d629906200131d9086908690869060040162002bdd565b600060405180830381600087803b1580156200133857600080fd5b505af115801562000a49573d6000803e3d6000fd5b505050565b60006200135f8262001a25565b600254604051637c8ee70360e01b81526001600160a01b0390911690637c8ee703906200139190859060040162002b8c565b60206040518083038186803b158015620013aa57600080fd5b505afa158015620013bf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d89190620026e1565b3f90565b333b15801562001418576012805484919060ff191660018360098111156200140d57fe5b021790555060016000f35b600062001426848462001ee8565b9050805160208201fd5b60006200143d8262001a25565b6002546040516307a1294560e01b81526001600160a01b03909116906307a12945906200146f90859060040162002b8c565b60206040518083038186803b1580156200148857600080fd5b505afa1580156200149d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005d891906200278a565b620014ce8162001a25565b600254604051637e78a4d160e11b81526001600160a01b039091169063fcf149a2906200150090849060040162002b8c565b600060405180830381600087803b1580156200151b57600080fd5b505af1158015620005ba573d6000803e3d6000fd5b60008151602083016000f092915050565b6060620005d88260006200155585620015be565b6200159c565b6200156683620018ff565b6002546040516368510af960e11b81526001600160a01b039091169063d0a215f2906200131d9086908690869060040162002ba0565b60606040519050602082018101604052818152818360208301863c9392505050565b3b90565b6000606073ffffffffffffffffffffffffffffffffffff0000841673deaddeaddeaddeaddeaddeaddeaddeaddead000014156200161357505060408051602081019091526000815260019062001650565b60006064856001600160a01b0316106200163857620016328562001352565b6200163a565b845b90506200164a8787838762001bf5565b92509250505b94509492505050565b80516009556020810151600a5560a0810151600c5560408101516008805460ff1916600183818111156200168957fe5b02179055506060810151600d80546001600160a01b0319166001600160a01b03909216919091179055600554600b5560a0810151620016c89062001fb3565b60115550565b60008060ff60f81b85848680519060200120604051602001620016f5949392919062002b2c565b60405160208183030381529060405280519060200120905062000a828162001bf2565b6004546000908311156200172f5750600062000f9d565b600354831015620017435750600062000f9d565b50600192915050565b600d80546001600160a01b031990811690915560006009819055600a819055600b819055600c8190556008805460ff199081169091556010829055600e8054909316909255600f80546001600160a81b0319169055601155601280549091169055565b6175305a1015620017c657620017c6600162000fa3565b600254604051630ad2267960e01b81526001600160a01b0390911690630ad2267990620017fa908590859060040162002bc4565b60206040518083038186803b1580156200181357600080fd5b505afa15801562001828573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200184e91906200278a565b6200185f576200185f600462000fa3565b600254604051632bcdee1960e21b81526000916001600160a01b03169063af37b8649062001894908690869060040162002bc4565b602060405180830381600087803b158015620018af57600080fd5b505af1158015620018c4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620018ea91906200278a565b9050806200134d576200134d614e2062001fc8565b6200190a8162001a25565b60025460405163011b1f7960e41b81526000916001600160a01b0316906311b1f790906200193d90859060040162002b8c565b602060405180830381600087803b1580156200195857600080fd5b505af11580156200196d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200199391906200278a565b905080620008af57600260009054906101000a90046001600160a01b03166001600160a01b03166333f943056040518163ffffffff1660e01b8152600401600060405180830381600087803b158015620019ec57600080fd5b505af115801562001a01573d6000803e3d6000fd5b50505050620008af617530606462001a1d62000a9c8662001352565b020162001fc8565b6175305a101562001a3c5762001a3c600162000fa3565b60025460405163c8e40fbf60e01b81526001600160a01b039091169063c8e40fbf9062001a6e90849060040162002b8c565b60206040518083038186803b15801562001a8757600080fd5b505afa15801562001a9c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001ac291906200278a565b62001ad35762001ad3600462000fa3565b600254604051633ecdecc760e21b81526000916001600160a01b03169063fb37b31c9062001b0690859060040162002b8c565b602060405180830381600087803b15801562001b2157600080fd5b505af115801562001b36573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001b5c91906200278a565b905080620008af57620008af617530606462001a1d62000a9c8662001352565b6060620005d88260405160200162001b95919062002b0f565b60405160208183030381529060405262001feb565b6060620005d862001bbb836200203c565b62001feb565b6060600062001bd0836200214d565b905062001beb62001be4825160c06200225a565b82620023b7565b9392505050565b90565b6040805160608082018352600e546001600160a01b039081168352600f549081166020840152600160a01b900460ff161515928201929092526000919062001c3e818862002438565b601154600062001c4e8862001fb3565b905080601160000181905550600080886001600160a01b03168a8960405162001c78919062002b65565b60006040518083038160008787f1925050503d806000811462001cb8576040519150601f19603f3d011682016040523d82523d6000602084013e62001cbd565b606091505b509150915062001cce8b8662002438565b6011548262001db05760008060008062001ce886620024ef565b92965090945092509050600484600981111562001d0157fe5b141562001d135762001d138462000fa3565b600284600981111562001d2257fe5b148062001d3b5750600584600981111562001d3957fe5b145b8062001d535750600784600981111562001d5157fe5b145b8062001d6b5750600984600981111562001d6957fe5b145b1562001d775760108290555b600284600981111562001d8657fe5b141562001d965780955062001da9565b6040518060200160405280600081525095505b5090925050505b909203909203601155909890975095505050505050565b62001dd38282620017af565b60025460405163af3dc01160e01b81526000916001600160a01b03169063af3dc0119062001e08908690869060040162002bc4565b602060405180830381600087803b15801562001e2357600080fd5b505af115801562001e38573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001e5e91906200278a565b9050806200134d5762001e7183620018ff565b600260009054906101000a90046001600160a01b03166001600160a01b031663c3fd9b256040518163ffffffff1660e01b8152600401600060405180830381600087803b15801562001ec257600080fd5b505af115801562001ed7573d6000803e3d6000fd5b505050506200134d614e2062001fc8565b6060600183600981111562001ef957fe5b148062001f125750600883600981111562001f1057fe5b145b1562001f2e575060408051602081019091526000815262000f9d565b600483600981111562001f3d57fe5b141562001f7f5760408051602080820183526000808352925162001f68938793909283920162002c89565b604051602081830303815290604052905062000f9d565b60115460105460405162001f9c9286929091869060200162002cc9565b604051602081830303815290604052905092915050565b60005a821062001fc4575a620005d8565b5090565b60115481111562001fdf5762001fdf600362000fa3565b60118054919091039055565b606080825160011480156200201557506080836000815181106200200b57fe5b016020015160f81c105b1562002023575081620005d8565b62000f9a62002035845160806200225a565b84620023b7565b606060008260405160200162002053919062002b83565b604051602081830303815290604052905060005b6020811015620020a2578181815181106200207e57fe5b01602001516001600160f81b031916156200209957620020a2565b60010162002067565b6000816020036001600160401b0381118015620020be57600080fd5b506040519080825280601f01601f191660200182016040528015620020ea576020820181803683370190505b50905060005b8151811015620021445783516001840193859181106200210c57fe5b602001015160f81c60f81b8282815181106200212457fe5b60200101906001600160f81b031916908160001a905350600101620020f0565b50949350505050565b6060815160001415620021705750604080516000815260208101909152620005db565b6000805b8351811015620021a6578381815181106200218b57fe5b60200260200101515182019150808060010191505062002174565b6000826001600160401b0381118015620021bf57600080fd5b506040519080825280601f01601f191660200182016040528015620021eb576020820181803683370190505b50600092509050602081015b8551831015620021445760008684815181106200221057fe5b602002602001015190506000602082019050620022308382845162002547565b8785815181106200223d57fe5b6020026020010151518301925050508280600101935050620021f7565b6060806038841015620022b7576040805160018082528183019092529060208201818036833701905050905082840160f81b816000815181106200229a57fe5b60200101906001600160f81b031916908160001a90535062000f9a565b600060015b808681620022c657fe5b0415620022dd5760019091019061010002620022bc565b816001016001600160401b0381118015620022f757600080fd5b506040519080825280601f01601f19166020018201604052801562002323576020820181803683370190505b50925084820160370160f81b836000815181106200233d57fe5b60200101906001600160f81b031916908160001a905350600190505b818111620023ae576101008183036101000a87816200237457fe5b04816200237d57fe5b0660f81b8382815181106200238e57fe5b60200101906001600160f81b031916908160001a90535060010162002359565b50509392505050565b6060806040519050835180825260208201818101602087015b81831015620023ea578051835260209283019201620023d0565b50855184518101855292509050808201602086015b8183101562002419578051835260209283019201620023ff565b508651929092011591909101601f01601f191660405250905092915050565b805182516001600160a01b0390811691161462002471578051600e80546001600160a01b0319166001600160a01b039092169190911790555b80602001516001600160a01b031682602001516001600160a01b031614620024b8576020810151600f80546001600160a01b0319166001600160a01b039092169190911790555b806040015115158260400151151514620008af5760400151600f8054911515600160a01b0260ff60a01b1990921691909117905550565b600080600060608451600014156200252157505060408051602081019091526000808252600193509150819062002540565b84806020019051810190620025379190620028c7565b93509350935093505b9193509193565b8282825b602081106200256c578151835260209283019290910190601f19016200254b565b905182516020929092036101000a6000190180199091169116179052505050565b6108648062002e3f83390190565b6000620025b2620025ac8462002dd7565b62002db3565b9050828152838383011115620025c757600080fd5b828260208301376000602084830101529392505050565b8035620005db8162002e28565b600082601f830112620025fc578081fd5b62000f9a838335602085016200259b565b803560028110620005db57600080fd5b600060e082840312156200262f578081fd5b6200263b60e062002db3565b9050813581526020820135602082015262002659604083016200260d565b60408201526200266c60608301620025de565b60608201526200267f60808301620025de565b608082015260a082013560a082015260c08201356001600160401b03811115620026a857600080fd5b620026b684828501620025eb565b60c08301525092915050565b600060208284031215620026d4578081fd5b813562000f9a8162002e28565b600060208284031215620026f3578081fd5b815162000f9a8162002e28565b6000806040838503121562002713578081fd5b8235620027208162002e28565b915060208301356001600160401b038111156200273b578182fd5b6200274985828601620025eb565b9150509250929050565b60008060006060848603121562002768578081fd5b8335620027758162002e28565b95602085013595506040909401359392505050565b6000602082840312156200279c578081fd5b8151801515811462000f9a578182fd5b600060208284031215620027be578081fd5b5035919050565b600060208284031215620027d7578081fd5b5051919050565b60008060408385031215620027f1578182fd5b50508035926020909101359150565b6000806000806080858703121562002816578182fd5b84359350602085013560ff811681146200282e578283fd5b93969395505050506040820135916060013590565b60006020828403121562002855578081fd5b81356001600160401b038111156200286b578182fd5b6200287984828501620025eb565b949350505050565b6000806040838503121562002894578182fd5b82356001600160401b03811115620028aa578283fd5b620028b885828601620025eb565b95602094909401359450505050565b60008060008060808587031215620028dd578182fd5b8451600a8110620028ec578283fd5b80945050602085015192506040850151915060608501516001600160401b0381111562002917578182fd5b8501601f8101871362002928578182fd5b805162002939620025ac8262002dd7565b8181528860208385010111156200294e578384fd5b6200296182602083016020860162002df9565b9598949750929550505050565b60006020828403121562002980578081fd5b81356001600160401b0381111562002996578182fd5b8201601f81018413620029a7578182fd5b62002879848235602084016200259b565b60008060408385031215620029cb578182fd5b82356001600160401b03811115620029e1578283fd5b620029ef858286016200261d565b925050602083013562002a028162002e28565b809150509250929050565b60008060006060848603121562002a22578081fd5b83356001600160401b0381111562002a38578182fd5b62002a46868287016200261d565b935050602084013562002a598162002e28565b9150604084013562002a6b8162002e28565b809150509250925092565b60008060006060848603121562002a8b578081fd5b83359250602084013562002a9f8162002e28565b915060408401356001600160401b0381111562002aba578182fd5b62002ac886828701620025eb565b9150509250925092565b6000815180845262002aec81602086016020860162002df9565b601f01601f19169290920160200192915050565b600a811062002b0b57fe5b9052565b60609190911b6bffffffffffffffffffffffff1916815260140190565b6001600160f81b031994909416845260609290921b6bffffffffffffffffffffffff191660018401526015830152603582015260550190565b6000825162002b7981846020870162002df9565b9190910192915050565b90815260200190565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b6001600160a01b039390931683526020830191909152604082015260600190565b6001600160a01b0383168152604060208201819052600090620028799083018462002ad2565b600083151582526040602083015262002879604083018462002ad2565b93845260ff9290921660208401526040830152606082015260800190565b60006020825262000f9a602083018462002ad2565b602081016002831062002c8357fe5b91905290565b600062002c97828762002b00565b60ff8516602083015260ff841660408301526080606083015262002cbf608083018462002ad2565b9695505050505050565b600062002cd7828762002b00565b8460208301528360408301526080606083015262002cbf608083018462002ad2565b60208082526046908201527f4f6e6c792061757468656e746963617465642061646472657373657320696e2060408201527f6f766d53746174654d616e616765722063616e2063616c6c20746869732066756060820152653731ba34b7b760d11b608082015260a00190565b6020808252602e908201527f4f6e6c792062652063616c6c61626c6520617420746865207374617274206f6660408201526d1030903a3930b739b0b1ba34b7b760911b606082015260800190565b6040518181016001600160401b038111828210171562002dcf57fe5b604052919050565b60006001600160401b0382111562002deb57fe5b50601f01601f191660200190565b60005b8381101562002e1657818101518382015260200162002dfc565b83811115620008ac5750506000910152565b6001600160a01b03811681146200049d57600080fdfe608060405234801561001057600080fd5b506040516108643803806108648339818101604052602081101561003357600080fd5b505161003e81610044565b506101c7565b6100877fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead60001b826001600160a01b031660001b61008a60201b6103ba1760201c565b50565b604080516024810184905260448082018490528251808303909101815260649091019091526020810180516001600160e01b03908116628af59360e61b179091526100d691906100db16565b505050565b60606100e75a836100ed565b92915050565b60606000339050600080826001600160a01b031686866040518082805190602001908083835b602083106101325780518252601f199092019160209182019101610113565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038160008787f1925050503d8060008114610195576040519150601f19603f3d011682016040523d82523d6000602084013e61019a565b606091505b509092509050816101ad57805160208201fd5b8051600114156101bd5760016000f35b92506100e7915050565b61068e806101d66000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80630900f010146100a1578063aaf10f42146100c9575b6000806100825a6100456100ed565b6000368080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061011d92505050565b91509150811561009457805160208201f35b61009d816102c0565b5050005b6100c7600480360360208110156100b757600080fd5b50356001600160a01b031661036a565b005b6100d16100ed565b604080516001600160a01b039092168252519081900360200190f35b60006101187fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead610406565b905090565b6000606060006101e586868660405160240180848152602001836001600160a01b0316815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561017e578181015183820152602001610166565b50505050905090810190601f1680156101ab5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b03166001620631bb60e21b0319179052945061046c9350505050565b90508080602001905160408110156101fc57600080fd5b81516020830180516040519294929383019291908464010000000082111561022357600080fd5b90830190602082018581111561023857600080fd5b825164010000000081118282018810171561025257600080fd5b82525081516020918201929091019080838360005b8381101561027f578181015183820152602001610267565b50505050905090810190601f1680156102ac5780820380516001836020036101000a031916815260200191505b506040525050509250925050935093915050565b610366816040516024018080602001828103825283818151815260200191508051906020019080838360005b838110156103045781810151838201526020016102ec565b50505050905090810190601f1680156103315780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b0316632a2a7adb60e01b179052925061046c915050565b5050565b6103ae61037561047e565b6001600160a01b03166103866104d4565b6001600160a01b0316146040518060600160405280603281526020016106276032913961050b565b6103b781610519565b50565b604080516024810184905260448082018490528251808303909101815260649091019091526020810180516001600160e01b0316628af59360e61b1790526104019061046c565b505050565b6040805160248082018490528251808303909101815260449091019091526020810180516001600160e01b03166303daa95960e01b179052600090819061044c9061046c565b905080806020019051602081101561046357600080fd5b50519392505050565b60606104785a8361054c565b92915050565b6040805160048152602481019091526020810180516001600160e01b0316631cd4241960e21b17905260009081906104b59061046c565b90508080602001905160208110156104cc57600080fd5b505191505090565b6040805160048152602481019091526020810180516001600160e01b031663996d79a560e01b17905260009081906104b59061046c565b8161036657610366816102c0565b6103b77fdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead6001600160a01b0383166103ba565b60606000339050600080826001600160a01b031686866040518082805190602001908083835b602083106105915780518252601f199092019160209182019101610572565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038160008787f1925050503d80600081146105f4576040519150601f19603f3d011682016040523d82523d6000602084013e6105f9565b606091505b5090925090508161060c57805160208201fd5b80516001141561061c5760016000f35b925061047891505056fe454f41732063616e206f6e6c792075706772616465207468656972206f776e20454f4120696d706c656d656e746174696f6ea26469706673582212207f82637ab24ef9653a9774102bad776ee1ee930f0e1d73dfcad1f8fd1b18609a64736f6c634300070600335369676e61747572652070726f766964656420666f7220454f4120636f6e7472616374206372656174696f6e20697320696e76616c69642ea2646970667358221220f054814893c33a58bbcbd4f73988d982d06877b6e63ed1b5a478541f1e64b5b164736f6c63430007060033",
  "devdoc": {
    "details": "The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed environment allowing us to execute OVM transactions deterministically on either Layer 1 or Layer 2. The EM's run() function is the first function called during the execution of any transaction on L2. For each context-dependent EVM operation the EM has a function which implements a corresponding OVM operation, which will read state from the State Manager contract. The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any context-dependent operations. Compiler used: solc Runtime target: EVM",
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_libAddressManager": "Address of the Address Manager."
        }
      },
      "ovmADDRESS()": {
        "returns": {
          "_ADDRESS": "Active ADDRESS within the current message context."
        }
      },
      "ovmCALL(uint256,address,bytes)": {
        "params": {
          "_address": "Address of the contract to call.",
          "_calldata": "Data to send along with the call.",
          "_gasLimit": "Amount of gas to be passed into this call."
        },
        "returns": {
          "_returndata": "Data returned by the call.",
          "_success": "Whether or not the call returned (rather than reverted)."
        }
      },
      "ovmCALLER()": {
        "returns": {
          "_CALLER": "Address of the CALLER within the current message context."
        }
      },
      "ovmCHAINID()": {
        "returns": {
          "_CHAINID": "Value of the chain's CHAINID within the global context."
        }
      },
      "ovmCREATE(bytes)": {
        "params": {
          "_bytecode": "Code to be used to CREATE a new contract."
        },
        "returns": {
          "_contract": "Address of the created contract."
        }
      },
      "ovmCREATE2(bytes,bytes32)": {
        "params": {
          "_bytecode": "Code to be used to CREATE2 a new contract.",
          "_salt": "Value used to determine the contract's address."
        },
        "returns": {
          "_contract": "Address of the created contract."
        }
      },
      "ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)": {
        "details": "Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks      because the contract we're creating is trusted (no need to do safety checking or to      handle unexpected reverts). Doesn't need to return an address because the address is      assumed to be the user's actual address.",
        "params": {
          "_messageHash": "Hash of a message signed by some user, for verification.",
          "_r": "Signature `r` parameter.",
          "_s": "Signature `s` parameter.",
          "_v": "Signature `v` parameter."
        }
      },
      "ovmDELEGATECALL(uint256,address,bytes)": {
        "params": {
          "_address": "Address of the contract to call.",
          "_calldata": "Data to send along with the call.",
          "_gasLimit": "Amount of gas to be passed into this call."
        },
        "returns": {
          "_returndata": "Data returned by the call.",
          "_success": "Whether or not the call returned (rather than reverted)."
        }
      },
      "ovmEXTCODECOPY(address,uint256,uint256)": {
        "params": {
          "_contract": "Address of the contract to copy code from.",
          "_length": "Total number of bytes to copy from the contract's code.",
          "_offset": "Offset in bytes from the start of contract code to copy beyond."
        },
        "returns": {
          "_code": "Bytes of code copied from the requested contract."
        }
      },
      "ovmEXTCODEHASH(address)": {
        "params": {
          "_contract": "Address of the contract to query the hash of."
        },
        "returns": {
          "_EXTCODEHASH": "Hash of the requested contract."
        }
      },
      "ovmEXTCODESIZE(address)": {
        "params": {
          "_contract": "Address of the contract to query the size of."
        },
        "returns": {
          "_EXTCODESIZE": "Size of the requested contract in bytes."
        }
      },
      "ovmGASLIMIT()": {
        "returns": {
          "_GASLIMIT": "Value of the block's GASLIMIT within the transaction context."
        }
      },
      "ovmGETNONCE()": {
        "returns": {
          "_nonce": "Nonce of the current contract."
        }
      },
      "ovmL1QUEUEORIGIN()": {
        "returns": {
          "_queueOrigin": "Address of the ovmL1QUEUEORIGIN within the current message context."
        }
      },
      "ovmL1TXORIGIN()": {
        "returns": {
          "_l1TxOrigin": "Address of the account which sent the tx into L2 from L1."
        }
      },
      "ovmNUMBER()": {
        "returns": {
          "_NUMBER": "Value of the NUMBER within the transaction context."
        }
      },
      "ovmREVERT(bytes)": {
        "params": {
          "_data": "Bytes data to pass along with the REVERT."
        }
      },
      "ovmSETNONCE(uint256)": {
        "params": {
          "_nonce": "New nonce for the current contract."
        }
      },
      "ovmSLOAD(bytes32)": {
        "params": {
          "_key": "32 byte key of the storage slot to load."
        },
        "returns": {
          "_value": "32 byte value of the requested storage slot."
        }
      },
      "ovmSSTORE(bytes32,bytes32)": {
        "params": {
          "_key": "32 byte key of the storage slot to set.",
          "_value": "32 byte value for the storage slot."
        }
      },
      "ovmSTATICCALL(uint256,address,bytes)": {
        "params": {
          "_address": "Address of the contract to call.",
          "_calldata": "Data to send along with the call.",
          "_gasLimit": "Amount of gas to be passed into this call."
        },
        "returns": {
          "_returndata": "Data returned by the call.",
          "_success": "Whether or not the call returned (rather than reverted)."
        }
      },
      "ovmTIMESTAMP()": {
        "returns": {
          "_TIMESTAMP": "Value of the TIMESTAMP within the transaction context."
        }
      },
      "run((uint256,uint256,uint8,address,address,uint256,bytes),address)": {
        "params": {
          "_ovmStateManager": "iOVM_StateManager implementation providing account state.",
          "_transaction": "Transaction data to be executed."
        }
      },
      "safeCREATE(address,bytes)": {
        "details": "This function is implemented as `public` because we need to be able to revert a      contract creation without losing information about exactly *why* the contract reverted.      In particular, we want to be sure that contracts cannot trigger an INVALID_STATE_ACCESS      flag and then revert to reset the flag. We're able to do this by making an external      call from `ovmCREATE` and `ovmCREATE2` to `safeCREATE`, which can capture and relay      information before reverting.",
        "params": {
          "_address": "Address of the contract to associate with the one being created.",
          "_bytecode": "Code to be used to create the new contract."
        }
      },
      "simulateMessage((uint256,uint256,uint8,address,address,uint256,bytes),address,address)": {
        "params": {
          "_from": "the OVM account the simulated call should be from.",
          "_transaction": "the message transaction to simulate."
        }
      }
    },
    "title": "OVM_ExecutionManager",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "ovmADDRESS()": {
        "notice": "Overrides ADDRESS."
      },
      "ovmCALL(uint256,address,bytes)": {
        "notice": "Overrides CALL."
      },
      "ovmCALLER()": {
        "notice": "Overrides CALLER."
      },
      "ovmCHAINID()": {
        "notice": "Overrides CHAINID."
      },
      "ovmCREATE(bytes)": {
        "notice": "Overrides CREATE."
      },
      "ovmCREATE2(bytes,bytes32)": {
        "notice": "Overrides CREATE2."
      },
      "ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)": {
        "notice": "Creates a new EOA contract account, for account abstraction."
      },
      "ovmDELEGATECALL(uint256,address,bytes)": {
        "notice": "Overrides DELEGATECALL."
      },
      "ovmEXTCODECOPY(address,uint256,uint256)": {
        "notice": "Overrides EXTCODECOPY."
      },
      "ovmEXTCODEHASH(address)": {
        "notice": "Overrides EXTCODEHASH."
      },
      "ovmEXTCODESIZE(address)": {
        "notice": "Overrides EXTCODESIZE."
      },
      "ovmGASLIMIT()": {
        "notice": "Overrides GASLIMIT."
      },
      "ovmGETNONCE()": {
        "notice": "Retrieves the nonce of the current ovmADDRESS."
      },
      "ovmL1QUEUEORIGIN()": {
        "notice": "Specifies from which L1 rollup queue this transaction originated from."
      },
      "ovmL1TXORIGIN()": {
        "notice": "Specifies which L1 account, if any, sent this transaction by calling enqueue()."
      },
      "ovmNUMBER()": {
        "notice": "Overrides NUMBER."
      },
      "ovmREVERT(bytes)": {
        "notice": "Overrides REVERT."
      },
      "ovmSETNONCE(uint256)": {
        "notice": "Sets the nonce of the current ovmADDRESS."
      },
      "ovmSLOAD(bytes32)": {
        "notice": "Overrides SLOAD."
      },
      "ovmSSTORE(bytes32,bytes32)": {
        "notice": "Overrides SSTORE."
      },
      "ovmSTATICCALL(uint256,address,bytes)": {
        "notice": "Overrides STATICCALL."
      },
      "ovmTIMESTAMP()": {
        "notice": "Overrides TIMESTAMP."
      },
      "run((uint256,uint256,uint8,address,address,uint256,bytes),address)": {
        "notice": "Starts the execution of a transaction via the OVM_ExecutionManager."
      },
      "safeCREATE(address,bytes)": {
        "notice": "Performs the logic to create a contract and revert under various potential conditions."
      },
      "simulateMessage((uint256,uint256,uint8,address,address,uint256,bytes),address,address)": {
        "notice": "Unreachable helper function for simulating eth_calls with an OVM message context. This function will throw an exception in all cases other than when used as a custom entrypoint in L2 Geth to simulate eth_call."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12337,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)12330"
      },
      {
        "astId": 4291,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "ovmSafetyChecker",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(iOVM_SafetyChecker)10816"
      },
      {
        "astId": 4293,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "ovmStateManager",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(iOVM_StateManager)11048"
      },
      {
        "astId": 4295,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "gasMeterConfig",
        "offset": 0,
        "slot": "3",
        "type": "t_struct(GasMeterConfig)10594_storage"
      },
      {
        "astId": 4297,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "globalContext",
        "offset": 0,
        "slot": "7",
        "type": "t_struct(GlobalContext)10597_storage"
      },
      {
        "astId": 4299,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "transactionContext",
        "offset": 0,
        "slot": "8",
        "type": "t_struct(TransactionContext)10610_storage"
      },
      {
        "astId": 4301,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "messageContext",
        "offset": 0,
        "slot": "14",
        "type": "t_struct(MessageContext)10620_storage"
      },
      {
        "astId": 4303,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "transactionRecord",
        "offset": 0,
        "slot": "16",
        "type": "t_struct(TransactionRecord)10613_storage"
      },
      {
        "astId": 4305,
        "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
        "label": "messageRecord",
        "offset": 0,
        "slot": "17",
        "type": "t_struct(MessageRecord)10625_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Lib_AddressManager)12330": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_contract(iOVM_SafetyChecker)10816": {
        "encoding": "inplace",
        "label": "contract iOVM_SafetyChecker",
        "numberOfBytes": "20"
      },
      "t_contract(iOVM_StateManager)11048": {
        "encoding": "inplace",
        "label": "contract iOVM_StateManager",
        "numberOfBytes": "20"
      },
      "t_enum(QueueOrigin)11644": {
        "encoding": "inplace",
        "label": "enum Lib_OVMCodec.QueueOrigin",
        "numberOfBytes": "1"
      },
      "t_enum(RevertFlag)10579": {
        "encoding": "inplace",
        "label": "enum iOVM_ExecutionManager.RevertFlag",
        "numberOfBytes": "1"
      },
      "t_struct(GasMeterConfig)10594_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.GasMeterConfig",
        "members": [
          {
            "astId": 10587,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "minTransactionGasLimit",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 10589,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "maxTransactionGasLimit",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 10591,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "maxGasPerQueuePerEpoch",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 10593,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "secondsPerEpoch",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(GlobalContext)10597_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.GlobalContext",
        "members": [
          {
            "astId": 10596,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmCHAINID",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(MessageContext)10620_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.MessageContext",
        "members": [
          {
            "astId": 10615,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmCALLER",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 10617,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmADDRESS",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 10619,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "isStatic",
            "offset": 20,
            "slot": "1",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(MessageRecord)10625_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.MessageRecord",
        "members": [
          {
            "astId": 10622,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "nuisanceGasLeft",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 10624,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "revertFlag",
            "offset": 0,
            "slot": "1",
            "type": "t_enum(RevertFlag)10579"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TransactionContext)10610_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.TransactionContext",
        "members": [
          {
            "astId": 10599,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmL1QUEUEORIGIN",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(QueueOrigin)11644"
          },
          {
            "astId": 10601,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmTIMESTAMP",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 10603,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmNUMBER",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 10605,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmGASLIMIT",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 10607,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmTXGASLIMIT",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 10609,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmL1TXORIGIN",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(TransactionRecord)10613_storage": {
        "encoding": "inplace",
        "label": "struct iOVM_ExecutionManager.TransactionRecord",
        "members": [
          {
            "astId": 10612,
            "contract": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol:OVM_ExecutionManager",
            "label": "ovmGasRefund",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}